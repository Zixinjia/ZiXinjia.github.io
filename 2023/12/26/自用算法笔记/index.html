<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>自用算法笔记(持续更新) | 西贝の小窝</title><meta name="author" content="contito"><meta name="copyright" content="contito"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="算法笔记1.第一章 基础算法时间复杂度重视思想  好的方法 课下 模板(重复3-5次)思想理解会背 然后做题目  根据数据量猜解法 常数指令 一次a+b ,i ++这种就是，假如给你一个1e6长度的数组，用n^2的算法的话，数据量就成了1e12,我们设计的算法肯定不能超过1e7~1e8,假如用n*log2 n ，算下来也就是1e7多一点，未必能超，也许能行。假如是1e3长度，那么n2也行。 注意：">
<meta property="og:type" content="article">
<meta property="og:title" content="自用算法笔记(持续更新)">
<meta property="og:url" content="http://jiazixin.xyz/2023/12/26/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="西贝の小窝">
<meta property="og:description" content="算法笔记1.第一章 基础算法时间复杂度重视思想  好的方法 课下 模板(重复3-5次)思想理解会背 然后做题目  根据数据量猜解法 常数指令 一次a+b ,i ++这种就是，假如给你一个1e6长度的数组，用n^2的算法的话，数据量就成了1e12,我们设计的算法肯定不能超过1e7~1e8,假如用n*log2 n ，算下来也就是1e7多一点，未必能超，也许能行。假如是1e3长度，那么n2也行。 注意：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://jiazixin.xyz/img/%E5%A3%81%E7%BA%B8/%E5%AD%A4%E7%8B%AC%E6%91%87%E6%BB%9A01.png">
<meta property="article:published_time" content="2023-12-26T14:51:20.737Z">
<meta property="article:modified_time" content="2023-12-30T15:30:08.836Z">
<meta property="article:author" content="contito">
<meta property="article:tag" content="算法(刷题向)">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jiazixin.xyz/img/%E5%A3%81%E7%BA%B8/%E5%AD%A4%E7%8B%AC%E6%91%87%E6%BB%9A01.png"><link rel="shortcut icon" href="/img/%E9%99%B6%E5%96%86%E5%A4%B4%E5%83%8F.jpg"><link rel="canonical" href="http://jiazixin.xyz/2023/12/26/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '自用算法笔记(持续更新)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-30 23:30:08'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/copyright.css"><link rel="stylesheet" href="/css/daohang.css?1"><link rel="stylesheet" href="/css/zidingyi.css?1"><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/footer.css"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@master/mainColor/heoMainColor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/tag-link/tag-link.css"><script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/progress_bar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/%E9%99%B6%E5%96%86%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E5%A3%81%E7%BA%B8/%E5%AD%A4%E7%8B%AC%E6%91%87%E6%BB%9A01.png')"><nav id="nav"><span id="blog-info"><a href="/" title="西贝の小窝"><span class="site-name">西贝の小窝</span></a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">自用算法笔记(持续更新)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-26T14:51:20.737Z" title="发表于 2023-12-26 22:51:20">2023-12-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-30T15:30:08.836Z" title="更新于 2023-12-30 23:30:08">2023-12-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%87%AA%E7%94%A8/">自用</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|&nbsp; <span class="post-meta-dianzan"><a class="dianzan" href="javascript:void(0)" onclick="dianzan()"><i class="fas fa-thumbs-up"></i></a><span class="post-meta-label"> 点赞:</span><span class="dianzan-count">0</span></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('/img/%E5%A3%81%E7%BA%B8/%E5%AD%A4%E7%8B%AC%E6%91%87%E6%BB%9A01.png');"></div><article class="post-content" id="article-container"><h1 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a>算法笔记</h1><h2 id="1-第一章-基础算法"><a href="#1-第一章-基础算法" class="headerlink" title="1.第一章 基础算法"></a>1.第一章 基础算法</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>重视思想 </p>
<p>好的方法 课下 模板(重复3-5次)思想理解会背 然后做题目 </p>
<h3 id="根据数据量猜解法"><a href="#根据数据量猜解法" class="headerlink" title="根据数据量猜解法"></a>根据数据量猜解法</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E9%87%8F%E7%8C%9C%E8%A7%A3%E6%B3%95.png"></p>
<p>常数指令 一次a+b ,i ++这种就是，假如给你一个1e6长度的数组，用n^2的算法的话，数据量就成了1e12,我们设计的算法肯定不能超过1e7~1e8,假如用n*log2 n ，算下来也就是1e7多一点，未必能超，也许能行。假如是1e3长度，那么n2也行。</p>
<p>注意：上面使用技巧的必要条件↑</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%8C%9C%E8%A7%A3%E6%B3%95%E6%8A%80%E5%B7%A7.png"></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F1.png"></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F2.png"></p>
<p>用这个就行，防止边界问题</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>思想也是分治,但是方法不一样</p>
<p>先划分区间，再合并</p>
<p>最后那个for是把temp拷贝回去 temp是记录递归排序的数组，每一步都在改变，不能最后直接输出temp</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> t[<span class="number">100010</span>];</span><br><span class="line"><span class="comment">/*void merge_sort(int a[],int l,int r){</span></span><br><span class="line"><span class="comment">    if(l == r)return;</span></span><br><span class="line"><span class="comment">    int mid = l + r &gt;&gt; 1;</span></span><br><span class="line"><span class="comment">    merge_sort(a,l,mid),merge_sort(a,mid+1,r);</span></span><br><span class="line"><span class="comment">    for(int i = l,j = l, k = mid + 1; i &lt;= r; i ++){</span></span><br><span class="line"><span class="comment">        if(j == mid + 1) </span></span><br><span class="line"><span class="comment">            t[i] = a[k ++];</span></span><br><span class="line"><span class="comment">        else if(k == r + 1)</span></span><br><span class="line"><span class="comment">            t[i] = a[j ++];</span></span><br><span class="line"><span class="comment">        else t[i] = a[j] &lt; a[k] ? a[j ++] : a[k ++];</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    for(int i = l; i &lt;= r; i ++)a[i]=t[i];</span></span><br><span class="line"><span class="comment">}*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>{</span><br><span class="line">    <span class="comment">//只剩一个元素的时候，已经有序，返回</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找数组中点下标</span></span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//递归给左半边排序</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(a,l,mid);</span><br><span class="line">    <span class="comment">//递归给右半边排序</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(a,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//以下是合并排序好的两个数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//k：遍历合并后的数组的下标</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//i:左半边数组的下标，j:右半边数组的下标</span></span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//左右半边都没遍历完</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r){</span><br><span class="line">        <span class="comment">//左边的元素小于右边的元素</span></span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; a[j]) </span><br><span class="line">            <span class="comment">//左边元素放如临时数组，并移动下标</span></span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        <span class="comment">//否则，右边元素放入临时数组并移动下标 </span></span><br><span class="line">        <span class="keyword">else</span> temp[k++] = a[j++];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//如果左边数组有剩余，则放入临时数组</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) temp[k++] = a[i++];</span><br><span class="line">    <span class="comment">//如果有边数组有剩余，则放入临时数组</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) temp[k++] = a[j++];</span><br><span class="line">    <span class="comment">//把临时数组中的元素拷贝至原数组</span></span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++){</span><br><span class="line">        a[i] = temp[k++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i ++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">merge_sort</span>(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i ++){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="例题-逆序对"><a href="#例题-逆序对" class="headerlink" title="例题 逆序对"></a>例题 逆序对</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/5103/%E8%AE%B2%E8%A7%A3%E5%BE%88%E5%A5%BD">https://www.acwing.com/solution/content/5103/讲解很好</a></p>
<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%88%86%E6%B2%BB.png"></p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>例题洛谷P7020，适用情况，要排序的数字值域小，但是n很大的情况，sort和快排这些适合值域大小都可以，n小点的情况</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A1%B6%E6%8E%92%E5%BA%8F.png"></p>
<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">没有单调性也可能二分（本质不是单调性）</span><br><span class="line"></span><br><span class="line">整数二分算法模板 —— 模板题 AcWing <span class="number">789.</span> 数的范围</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>{<span class="comment">/* ... */</span>} <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">浮点数二分算法模板 —— 模板题 AcWing <span class="number">790.</span> 数的三次方根</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>{<span class="comment">/* ... */</span>} <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>想清楚性质 边界</p>
<p>无解和二分无关，可以用二分出的结果判断原题有没有解</p>
<p>浮点数二分更简单，l和r距离足够小就可以认为是个数了 </p>
<p>而且不用考虑向上向下取整 直接/2</p>
<p>浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>{<span class="comment">/* ... */</span>} <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>有经验，就是假如题目要求4位的话，最好-6，就是比要求的多两位，保证没问题</strong></p>
<p>例题<img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86.png"></p>
<h4 id="二分答案（10-15-10-17-11-13）"><a href="#二分答案（10-15-10-17-11-13）" class="headerlink" title="二分答案（10.15-10.17 11.13）"></a>二分答案（10.15-10.17 11.13）</h4><h4 id="关于lower-bound-和upper-bound-的常见用法"><a href="#关于lower-bound-和upper-bound-的常见用法" class="headerlink" title="关于lower_bound( )和upper_bound( )的常见用法"></a>关于lower_bound( )和upper_bound( )的常见用法</h4><h3 id="高精度（略过）"><a href="#高精度（略过）" class="headerlink" title="高精度（略过）"></a>高精度（略过）</h3><h3 id="前缀和-和-差分"><a href="#前缀和-和-差分" class="headerlink" title="前缀和 和 差分"></a>前缀和 和 差分</h3><p>一维前缀和 —— 模板题 AcWing 795. 前缀和<br><code>S[i] = a[1] + a[2] + ... a[i]</code><br><code>a[l] + ... + a[r] = S[r] - S[l - 1]</code></p>
<p>二维前缀和 —— 模板题 AcWing 796. 子矩阵的和</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.png">S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</p>
<p>一维差分 —— 模板题 AcWing 797. 差分<br>给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c</p>
<p>先得到差分数组</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%B7%AE%E5%88%86.png"></p>
<p>二维差分 —— 模板题 AcWing 798. 差分矩阵<br>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c</p>
<p>这个讲解很好<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/27325/">https://www.acwing.com/solution/content/27325/</a></p>
<h3 id="位运算-待更"><a href="#位运算-待更" class="headerlink" title="位运算(待更)"></a>位运算(待更)</h3><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E5%8C%96.png"></p>
<p>如果数据范围小的话（10的五次方以内）用前缀和也可</p>
<p>C++用vector作离散化</p>
<p>下面是去重函数的用法</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tjcwt2011/article/details/125281748?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169275072116800184115652%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169275072116800184115652&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-125281748-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=C++%E5%8E%BB%E9%87%8D%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/tjcwt2011/article/details/125281748?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169275072116800184115652%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169275072116800184115652&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-125281748-null-null.142^v93^chatgptT3_1&amp;utm_term=C%2B%2B%E5%8E%BB%E9%87%8D%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187</a></p>
<p>去重完用sort排序最后用二分查找（好像是先排序后去重</p>
<p>二分函数lower_bound（大于等于） upper_bound（大于）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51566349/article/details/128086465?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=lower_bound&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-128086465.nonecase&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_51566349/article/details/128086465?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=lower_bound&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-128086465.nonecase&amp;spm=1018.2226.3001.4187</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/80100/%E8%BF%99%E4%B8%AA%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E9%9D%9E%E5%B8%B8%E8%AF%A6%E7%BB%86">https://www.acwing.com/solution/content/80100/这个代码解释非常详细</a></p>
<p>csdn的这个博客也很不错(11.11)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54773252/article/details/123286277?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169968370116800182120590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=169968370116800182120590&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~hot_rank-2-123286277-null-null.nonecase&amp;utm_term=%E7%A6%BB%E6%95%A3%E5%8C%96&amp;spm=1018.2226.3001.4450">https://blog.csdn.net/qq_54773252/article/details/123286277?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169968370116800182120590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=169968370116800182120590&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~hot_rank-2-123286277-null-null.nonecase&amp;utm_term=%E7%A6%BB%E6%95%A3%E5%8C%96&amp;spm=1018.2226.3001.4450</a></p>
<h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><p>好多端点问题都是贪心</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/2615/%E6%9B%B4%E6%96%B0%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%EF%BC%88%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%89">https://www.acwing.com/solution/content/2615/更新维护区间（很重要）</a></p>
<h2 id="2-第二章-数据结构"><a href="#2-第二章-数据结构" class="headerlink" title="2.第二章 数据结构"></a>2.第二章 数据结构</h2><h3 id="链表和邻接表"><a href="#链表和邻接表" class="headerlink" title="链表和邻接表"></a>链表和邻接表</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>用的最多的是邻接表</p>
<p>（存储图和树）</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/16251/">https://www.acwing.com/solution/content/16251/</a></p>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>添加的顺序不能反</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8F%8C%E9%93%BE%E8%A1%A8.png"></p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><p>表达式求值(中缀 后缀）一般是二元（不包括符号）</p>
<h3 id="单调栈（2023-12-15）"><a href="#单调栈（2023-12-15）" class="headerlink" title="单调栈（2023.12.15）"></a>单调栈（2023.12.15）</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%95%E8%B0%83%E6%A0%88.png"></p>
<p>例题洛谷P2866</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%95%E8%B0%83%E6%A0%88%E4%BE%8B%E9%A2%98.png"></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ans= <span class="number">0</span>; </span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;=n ; i ++){</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;	</span><br><span class="line">		<span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;st.<span class="built_in">top</span>()&lt;=x){</span><br><span class="line">				st.<span class="built_in">pop</span>();</span><br><span class="line">				cnt--; </span><br><span class="line">			}</span><br><span class="line">			ans+=cnt;</span><br><span class="line">			st.<span class="built_in">push</span>(x);</span><br><span class="line">			cnt++;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>用STL的双端队列deque非常方便</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97.png"></p>
<p>例题 洛谷P2032</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>{<span class="type">int</span> v,id;}a[N];</span><br><span class="line">deque&lt;node&gt; q;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i &lt;= n; i ++){</span><br><span class="line">		cin &gt;&gt; a[i].v;</span><br><span class="line">		a[i].id = i;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++){</span><br><span class="line">		<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;q.<span class="built_in">back</span>().v&lt;a[i].v){</span><br><span class="line">			q.<span class="built_in">pop_back</span>();</span><br><span class="line">		}</span><br><span class="line">		q.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">		<span class="keyword">if</span>(q.<span class="built_in">front</span>().id==i-k)q.<span class="built_in">pop_front</span>();</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k)cout &lt;&lt; q.<span class="built_in">front</span>().v&lt;&lt;endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>虽然抽象但是题型固定就那几个</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/27437/">https://www.acwing.com/solution/content/27437/</a> 这个非常易于适合理解单调栈</p>
<p>单调栈：见博客</p>
<p>单调队列：见博客<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_50285142/article/details/120245122?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169761847116800180675961%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169761847116800180675961&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120245122-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/qq_50285142/article/details/120245122?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169761847116800180675961%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169761847116800180675961&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120245122-null-null.142^v96^pc_search_result_base1&amp;utm_term=%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97&amp;spm=1018.2226.3001.4187</a></p>
<h3 id="kmp算法（略）"><a href="#kmp算法（略）" class="headerlink" title="kmp算法（略）"></a>kmp算法（略）</h3><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><p>题一般字符串字母类型少</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"></p>
<p>算法竞赛里的trie树最多26个或者52个字母</p>
<h3 id="并查集-12-8"><a href="#并查集-12-8" class="headerlink" title="并查集(12.8)"></a>并查集(12.8)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/qmjuMW/">https://leetcode.cn/circle/discuss/qmjuMW/</a></p>
<h3 id="堆（12-19）"><a href="#堆（12-19）" class="headerlink" title="堆（12.19）"></a>堆（12.19）</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%A0%86.png"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010452388/article/details/81283998?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169767827616800197017127%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=169767827616800197017127&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~hot_rank-5-81283998-null-null.nonecase&amp;utm_term=%E5%A0%86&amp;spm=1018.2226.3001.4450">https://blog.csdn.net/u010452388/article/details/81283998?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169767827616800197017127%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=169767827616800197017127&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~hot_rank-5-81283998-null-null.nonecase&amp;utm_term=%E5%A0%86&amp;spm=1018.2226.3001.4450</a></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%A0%86%E7%BB%93%E6%9E%84%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F.png"></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%A0%86.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/120483/">https://www.acwing.com/solution/content/120483/</a></p>
<p>堆排序：</p>
<p>从最后一个非叶子节点开始</p>
<p>向上调整</p>
<p>向下调整</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>字符串哈希适用场景：不考虑冲突，不能映射成0</p>
<p>字符串前缀哈希值</p>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><h5 id="例题-动态求区间和"><a href="#例题-动态求区间和" class="headerlink" title="例题 动态求区间和"></a>例题 动态求区间和</h5><h6 id="树状数组-1"><a href="#树状数组-1" class="headerlink" title="树状数组"></a>树状数组</h6><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100009</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],tr[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个数的间隔，背下来就行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//第x个数加上v</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//因为树状数组的性质，加一个数，只影响logn个数，所有不用全加完</span></span><br><span class="line">    <span class="comment">//从当前位置开始加，每个间隔是lowbit(i)，一直加到最后</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        tr[i]+=v;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回x的前缀和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qurry</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//因为树状数组的性质，求前缀和，只用加logn个数，所有不用全加完</span></span><br><span class="line">    <span class="comment">//从当前位置开始累加，每个间隔是lowbit(i)，一直加到i==0停止</span></span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i!=<span class="number">0</span>;i-=<span class="built_in">lowbit</span>(i)){</span><br><span class="line">        cnt+=tr[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">add</span>(i,a[i]);<span class="comment">//第i个数加上a[i]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> k,x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;k,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">qurry</span>(y)-<span class="built_in">qurry</span>(x<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">add</span>(x,y);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h6 id="这道题的线段树方法"><a href="#这道题的线段树方法" class="headerlink" title="这道题的线段树方法"></a>这道题的线段树方法</h6><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"></p>
<h6 id="4倍空间的原因"><a href="#4倍空间的原因" class="headerlink" title="4倍空间的原因"></a>4倍空间的原因</h6><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%AE%B5%E6%A0%914%E5%80%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8E%9F%E5%9B%A0.png"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N];<span class="comment">//记录一下权重</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>{</span><br><span class="line">    <span class="type">int</span> l,r;<span class="comment">//左右区间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum;<span class="comment">//总和</span></span><br><span class="line">}tr[N*<span class="number">4</span>];<span class="comment">//记得开 4 倍空间 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//利用它的两个儿子来算一下它的当前节点信息</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;<span class="comment">//左儿子 u&lt;&lt;1 ,右儿子 u&lt;&lt;1|1  </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">/*第一个参数，当前节点编号，第二个参数，左边界，第三个参数，右边界*/</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(l==r)tr[u]={l,r,w[r]};<span class="comment">//如果当前已经是叶节点了，那我们就直接赋值就可以了</span></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则的话，说明当前区间长度至少是 2 对吧，那么我们需要把当前区间分为左右两个区间，那先要找边界点</span></span><br><span class="line">    {</span><br><span class="line">        tr[u]={l,r};<span class="comment">//这里记得赋值一下左右边界的初值</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="comment">//边界的话直接去计算一下 l + r 的下取整</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);<span class="comment">//先递归一下左儿子</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);<span class="comment">//然后递归一下右儿子</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">push_up</span>(u);<span class="comment">//做完两个儿子之后的话呢 push_up 一遍u 啊，更新一下当前节点信息</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">//查询的过程是从根结点开始往下找对应的一个区间</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;tr[u].r&lt;=r)<span class="keyword">return</span> tr[u].sum;<span class="comment">//如果当前区间已经完全被包含了，那么我们直接返回它的值就可以了</span></span><br><span class="line">    <span class="comment">//否则的话我们需要去递归来算</span></span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;<span class="comment">//计算一下我们 当前 区间的中点是多少</span></span><br><span class="line">    <span class="comment">//先判断一下和左边有没有交集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;<span class="comment">//用 sum 来表示一下我们的总和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=l)sum+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);<span class="comment">//看一下我们当前区间的中点和左边有没有交集</span></span><br><span class="line">    <span class="keyword">if</span>(r&gt;=mid+<span class="number">1</span>)<span class="comment">//看一下我们当前区间的中点和右边有没有交集</span></span><br><span class="line">    sum+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> v)</span><span class="comment">//第一个参数也就是当前节点的编号,第二个参数是要修改的位置，第三个参数是要修改的值</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==tr[u].r)tr[u].sum+=v; <span class="comment">//如果当前已经是叶节点了，那我们就直接让他的总和加上 v 就可以了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//否则</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//看一下 x 是在左半边还是在右半边</span></span><br><span class="line">      <span class="keyword">if</span>(x&lt;=mid)<span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,x,v);<span class="comment">//如果是在左半边，那就找左儿子</span></span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,v);<span class="comment">//如果在右半边，那就找右儿子</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//更新完之后当前节点的信息就要发生变化对吧，那么我们就需要 pushup 一遍</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">push_up</span>(u);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);<span class="comment">/*第一个参数是根节点的下标，根节点是一号点，然后初始区间是 1 到 n */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//后面的话就是一些修改操作了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> k,a,b;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!k)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">query</span>(<span class="number">1</span>,a,b));<span class="comment">//求和的时候，也是传三个参数，第一个的话是根节点的编号 ，第二个的话是我们查询的区间 </span></span><br><span class="line">        <span class="comment">//第一个参数也就是当前节点的编号</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,a,b);<span class="comment">//第一个参数是根节点的下标,第二个参数是要修改的位置，第三个参数是要修改的值</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">作者：Elegant</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/40394/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="区间求和例题-洛谷P3368"><a href="#区间求和例题-洛谷P3368" class="headerlink" title="区间求和例题:洛谷P3368"></a>区间求和例题:洛谷P3368</h5><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E4%BE%8B%E9%A2%98.png"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> b[N];</span><br><span class="line"><span class="type">int</span> tr[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> c)</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt;= n; i += <span class="built_in">lowbit</span>(i)){</span><br><span class="line">		tr[i] += c;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i)){</span><br><span class="line">		res += tr[i];</span><br><span class="line">	}	</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++){</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		b[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">add</span>(i,b[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(m --){</span><br><span class="line">		<span class="type">int</span> op;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span>(op == <span class="number">1</span>){</span><br><span class="line">			<span class="type">int</span> x,y,k;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">			<span class="built_in">add</span>(x,k);</span><br><span class="line">			<span class="built_in">add</span>(y + <span class="number">1</span>,-k);</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="type">int</span> x;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			cout &lt;&lt; <span class="built_in">query</span>(x) &lt;&lt; endl;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="线段树-待更"><a href="#线段树-待更" class="headerlink" title="线段树(待更)"></a>线段树(待更)</h3><h2 id="3-第三章-搜索与图论"><a href="#3-第三章-搜索与图论" class="headerlink" title="3.第三章 搜索与图论"></a>3.第三章 搜索与图论</h2><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/DFS%E5%92%8CBFS.png"></p>
<h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/DFS.png"></p>
<p>两个很重要的概念：回溯 剪枝</p>
<p>每个DFS都一定对应一个搜索树</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/30988/">https://www.acwing.com/solution/content/30988/</a></p>
<p>** 经典题目**</p>
<p><strong>八皇后</strong></p>
<h3 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h3><p>不是所有最短路都用BFS，只能当边权都是1时，一般情况都是用最短路算法</p>
<p>BFS函数里一般都用队列</p>
<h3 id="树与图的存储（10-21）"><a href="#树与图的存储（10-21）" class="headerlink" title="树与图的存储（10.21）"></a>树与图的存储（10.21）</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mJ411S7BB/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4452cbcad134fb17ec9cfb03a0acbdac">https://www.bilibili.com/video/BV1mJ411S7BB/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4452cbcad134fb17ec9cfb03a0acbdac</a></p>
<p>这个链式前向星讲的特别好↑</p>
<p>树是特殊的图，所以只讲图就行</p>
<p>图：有向图，无向图，边有无方向，无向图可以看作特殊的有向图，所以只要看有向图</p>
<p>有向图（a-&gt;b)：</p>
<p>邻接矩阵g[a] [b]  a-&gt;b,有重边保留一条就可以了</p>
<p>邻接表			</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E8%A1%A8.png">			</p>
<h3 id="树与图的深度优先遍历"><a href="#树与图的深度优先遍历" class="headerlink" title="树与图的深度优先遍历"></a>树与图的深度优先遍历</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.png" alt="image-20231204141022311"></p>
<p> **<a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/FyPTTM/**%E5%AE%9D%E8%97%8F">https://leetcode.cn/circle/discuss/FyPTTM/**宝藏</a></p>
<p>讲解了为什么要反向建边 <a target="_blank" rel="noopener" href="https://www.163.com/dy/article/E01JK0430538071X.html">https://www.163.com/dy/article/E01JK0430538071X.html</a></p>
<p><strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3916">https://www.luogu.com.cn/problem/P3916</a></strong></p>
<p>洛谷这个题↑正向遍历超时了 n 1e5 ，用反向遍历更适合</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8F%8D%E5%90%91%E5%BB%BA%E8%BE%B9.png"></p>
<p>思路真妙，把大的先走完，打上标记，肯定就是最大的了</p>
<p><strong>图的讲解</strong>(2023.12.4很好) <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/P5318">https://www.luogu.com.cn/problem/solution/P5318</a></p>
<p><strong>这个邻接表写法</strong>nice↓</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> visited[MAXN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> cur)</span> </span>{<span class="comment">//x指当前所在的节点，cur指已遍历过的节点个数</span></span><br><span class="line">	visited[x] = <span class="literal">true</span>;<span class="comment">//标记以避免重复访问</span></span><br><span class="line">	cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;<span class="comment">//输出</span></span><br><span class="line">	<span class="keyword">if</span> (cur == n) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;G[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">		<span class="keyword">if</span> (!visited[G[x][i]]) <span class="built_in">dfs</span>(G[x][i], cur+<span class="number">1</span>);<span class="comment">//记得要判断是否遍历过</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">	<span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="built_in">sizeof</span>(visited));<span class="comment">//记得一定要清空</span></span><br><span class="line">	visited[x] = <span class="literal">true</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(x);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">		<span class="type">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();<span class="comment">//记得要弹出，否则会一直在第一层遍历</span></span><br><span class="line">		cout &lt;&lt; v &lt;&lt; <span class="string">" "</span>;<span class="comment">//输出</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;G[v].<span class="built_in">size</span>(); i++) </span><br><span class="line">			<span class="keyword">if</span> (!visited[G[v][i]]) {</span><br><span class="line">				visited[G[v][i]] = <span class="literal">true</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(G[v][i]);<span class="comment">//记得要入队</span></span><br><span class="line">			}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) {</span><br><span class="line">		<span class="type">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		G[u].<span class="built_in">push_back</span>(v);<span class="comment">//标准邻接表建有向图</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(), G[i].<span class="built_in">end</span>());<span class="comment">//标准vector排序</span></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//完结撒花！</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<p><strong>非常重要</strong>!!!由前+中/后+中构建序列 模板（字符串切割 + 练习STL substr）</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/P1827">https://www.luogu.com.cn/problem/solution/P1827</a> </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">由中序和前序求后序</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string pre,inor;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string pre,string inor)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(pre.<span class="built_in">empty</span>())<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">char</span> root = pre[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> k = inor.<span class="built_in">find</span>(root);</span><br><span class="line">    pre.<span class="built_in">erase</span>(pre.<span class="built_in">begin</span>());</span><br><span class="line">    string leftpre = pre.<span class="built_in">substr</span>(<span class="number">0</span>,k);</span><br><span class="line">    string rightpre = pre.<span class="built_in">substr</span>(k);</span><br><span class="line">    string leftinor = inor.<span class="built_in">substr</span>(<span class="number">0</span>,k);</span><br><span class="line">    string rightinor = inor.<span class="built_in">substr</span>(k + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(leftpre,leftinor);</span><br><span class="line">    <span class="built_in">dfs</span>(rightpre,rightinor);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,root);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin &gt;&gt; inor &gt;&gt;pre ;</span><br><span class="line">    <span class="built_in">dfs</span>(pre,inor);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1030">https://www.luogu.com.cn/problem/P1030</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">由中序和后序求前序</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string inor,post;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(string inor,string post)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(post.<span class="built_in">empty</span>())<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">char</span> root = post[post.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    post.<span class="built_in">erase</span>(post.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> k = inor.<span class="built_in">find</span>(root);</span><br><span class="line">    </span><br><span class="line">    string inorleft = inor.<span class="built_in">substr</span>(<span class="number">0</span>,k);</span><br><span class="line">    string inorright= inor.<span class="built_in">substr</span>(k + <span class="number">1</span>);</span><br><span class="line">    string postleft = post.<span class="built_in">substr</span>(<span class="number">0</span>,k);</span><br><span class="line">    string postright = post.<span class="built_in">substr</span>(k);</span><br><span class="line">    cout &lt;&lt; root;</span><br><span class="line">    <span class="built_in">solve</span>(inorleft,postleft);</span><br><span class="line">    <span class="built_in">solve</span>(inorright,postright);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin &gt;&gt; inor &gt;&gt; post;</span><br><span class="line">    <span class="built_in">solve</span>(inor,post);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string pre,inor;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(string pre,string inor)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(pre.<span class="built_in">empty</span>())<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果序列空了，就没必要继续了</span></span><br><span class="line">    <span class="type">char</span> root=pre[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//取到前序序列的首字母，即根节点</span></span><br><span class="line">    <span class="type">int</span> k=inor.<span class="built_in">find</span>(root);</span><br><span class="line">    <span class="comment">//找到中序序列中根节点的位置</span></span><br><span class="line">    pre.<span class="built_in">erase</span>(pre.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="comment">//删去前序序列中的根节点</span></span><br><span class="line">    string leftpre=pre.<span class="built_in">substr</span>(<span class="number">0</span>,k);</span><br><span class="line">    <span class="comment">//从0开始切割k个</span></span><br><span class="line">    string rightpre=pre.<span class="built_in">substr</span>(k);</span><br><span class="line">    <span class="comment">//从k开始切割到最后</span></span><br><span class="line">    string leftinor=inor.<span class="built_in">substr</span>(<span class="number">0</span>,k);</span><br><span class="line">    <span class="comment">//从0开始切割k个</span></span><br><span class="line">    string rightinor=inor.<span class="built_in">substr</span>(k+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//从k+1开始切割到最后</span></span><br><span class="line">    <span class="built_in">work</span>(leftpre,leftinor);</span><br><span class="line">    <span class="built_in">work</span>(rightpre,rightinor);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,root);</span><br><span class="line">    <span class="comment">//因为要输出后序序列，所以是左右根</span></span><br><span class="line">    <span class="comment">//先遍历左子树，再右子树，再根节点</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin&gt;&gt;inor&gt;&gt;pre;</span><br><span class="line">    <span class="built_in">work</span>(pre,inor);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="树与图的宽度优先遍历-待更"><a href="#树与图的宽度优先遍历-待更" class="headerlink" title="树与图的宽度优先遍历(待更)"></a>树与图的宽度优先遍历(待更)</h3><h3 id="DAG-与-拓扑排序（12-4）"><a href="#DAG-与-拓扑排序（12-4）" class="headerlink" title="DAG() 与 拓扑排序（12.4）"></a>DAG() 与 拓扑排序（12.4）</h3><p><strong>知乎的讲解</strong>，很好↓[知识点]</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/135094687">https://zhuanlan.zhihu.com/p/135094687</a></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F1.png"></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F2.png"></p>
<p><strong>拓扑排序邻接表版</strong>[代码]</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/850/">https://www.acwing.com/problem/content/850/</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];<span class="comment">//邻接表 </span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//队列操作 </span></span><br><span class="line"><span class="type">int</span> d[N];<span class="comment">//统计入度 </span></span><br><span class="line"><span class="type">int</span> n,m,cnt,ans[N];<span class="comment">//ans数组记录答案 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i &lt;= m; i ++){</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		cin &gt;&gt; x&gt;&gt; y;</span><br><span class="line">		G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		d[y]++;<span class="comment">//统计入度 </span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>; i &lt;= n; i ++){</span><br><span class="line">		<span class="keyword">if</span>(d[i]==<span class="number">0</span>)q.<span class="built_in">push</span>(i);<span class="comment">//1</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line">		<span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		ans[cnt++] = t;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; G[t].<span class="built_in">size</span>();i  ++){</span><br><span class="line">			d[G[t][i]]--;<span class="comment">//删边操作 </span></span><br><span class="line">			<span class="keyword">if</span>(d[G[t][i]]==<span class="number">0</span>) q.<span class="built_in">push</span>(G[t][i]);<span class="comment">//删完后入度为0的话，放入队列 </span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(cnt == n)<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;cnt; i ++)cout &lt;&lt; ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt;<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>例题</strong></p>
<p><strong>我发现下面两道需要拓扑的题，只需要把一些求ans的代码放到模板里，模板还是不变的</strong></p>
<p>1 .洛谷P1113 杂务</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	每个任务前的耗时最长的任务相加即为答案，详情看洛谷深入浅出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ind[N], f[N], a[N];  <span class="comment">// ind--入度   f--答案   a--时间</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edge[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            cin &gt;&gt; y;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            edge[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">            ind[x]++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 步骤一</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (ind[i] == <span class="number">0</span>) {</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            f[i] = a[i];</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="type">int</span> rhs = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 步骤二</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edge[rhs].<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="type">int</span> u = edge[rhs][i];</span><br><span class="line">            ind[u]--;</span><br><span class="line">            <span class="keyword">if</span> (ind[u] == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(u);  <span class="comment">// 步骤三</span></span><br><span class="line">            f[u] = <span class="built_in">max</span>(f[u], f[rhs] + a[u]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[i]);   <span class="comment">// 统计答案</span></span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>2.P4017 最大食物链计数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	先找出所有入度为0的，初始链数为1，后面搜到的每个点，都等于各个点链数之和，详情看洛谷深入浅出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> ans[N],outd[N],ind[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;G[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++){</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        ind[y]++;</span><br><span class="line">        outd[x]++;</span><br><span class="line">        G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++){</span><br><span class="line">        <span class="keyword">if</span>(ind[i]==<span class="number">0</span>){</span><br><span class="line">            q.<span class="built_in">push</span>(i);  </span><br><span class="line">			ans[i] = <span class="number">1</span>; </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line">    <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; G[t].<span class="built_in">size</span>(); i ++){</span><br><span class="line">        <span class="type">int</span> x = G[t][i];</span><br><span class="line">        ind[x] --;</span><br><span class="line">		<span class="keyword">if</span>(ind[x]==<span class="number">0</span>){</span><br><span class="line">            q.<span class="built_in">push</span>(x);</span><br><span class="line">        }</span><br><span class="line">        ans[x] = (ans[x] + ans[t])%<span class="number">80112002</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++){</span><br><span class="line">    <span class="keyword">if</span>(outd[i]==<span class="number">0</span>){</span><br><span class="line">        res= (res + ans[i])%<span class="number">80112002</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; res;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="力扣总结精华"><a href="#力扣总结精华" class="headerlink" title="力扣总结精华"></a>力扣总结精华</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/FyPTTM/#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">https://leetcode.cn/circle/discuss/FyPTTM/#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84</a> </p>
<p>有权单源最短路</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9C%89%E6%9D%83%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.png"></p>
<p>无权单源最短路</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%97%A0%E6%9D%83%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF.png"></p>
<p>带权全源最短路</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%B8%A6%E6%9D%83%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.png"></p>
<p>如果是无权单源，可以BFS+队列，有权就不行了</p>
<h5 id="带权单源最短路"><a href="#带权单源最短路" class="headerlink" title="带权单源最短路"></a>带权单源最短路</h5><h6 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h6><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89.png"></p>
<p><strong>视频演示</strong>：</p>
<p> <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zz4y1m7Nq/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=4452cbcad134fb17ec9cfb03a0acbdac">https://www.bilibili.com/video/BV1zz4y1m7Nq/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=4452cbcad134fb17ec9cfb03a0acbdac</a></p>
<p>各个算法用途比较</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%90%84%E7%A7%8D%E6%AF%94%E8%BE%83.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/5806/">https://www.acwing.com/solution/content/5806/</a>  代码详解</p>
<h6 id="朴素版"><a href="#朴素版" class="headerlink" title="朴素版"></a>朴素版</h6><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N];    <span class="comment">//为稠密阵所以用邻接矩阵存储</span></span><br><span class="line"><span class="type">int</span> dist[N];    <span class="comment">//用于记录每一个点距离第一个点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">//用于记录该点的最短距离是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);     <span class="comment">//初始化距离  0x3f代表无限大</span></span><br><span class="line"></span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;  <span class="comment">//第一个点到自身的距离为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)      <span class="comment">//有n个点所以要进行n次 迭代</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> t=<span class="number">-1</span>;       <span class="comment">//t存储当前访问的点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)   <span class="comment">//这里的j代表的是从1号点开始</span></span><br><span class="line">        <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[j]&lt;dist[t]))     </span><br><span class="line">            t=j;</span><br><span class="line"></span><br><span class="line">    st[t]=<span class="literal">true</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)           <span class="comment">//依次更新每个点所到相邻的点路径值</span></span><br><span class="line">        dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//如果第n个点路径为无穷大即不存在最低路径</span></span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);    <span class="comment">//初始化图 因为是求最短路径</span></span><br><span class="line">                            <span class="comment">//所以每个点初始为无限大</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">    g[x][y]=<span class="built_in">min</span>(g[x][y],z);     <span class="comment">//如果发生重边的情况则保留最短的一条边</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">Dijkstra</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>对于「稠密图」，应当使用「朴素版」，对于「稀疏图」，应当使用「优先队列版」</strong></p>
<h6 id="堆优化版"><a href="#堆优化版" class="headerlink" title="堆优化版"></a>堆优化版</h6><p><strong>（vector邻接表，但是大多用的还是数组模拟邻接表）</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	邻接表存的话不用考虑重边，dij算法会取最小的</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 稀疏图用邻接表来存</span></span><br><span class="line">vector&lt;vector&lt;PII&gt;&gt;G;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，</span></span><br><span class="line">    <span class="comment">// 其次在从堆中拿出来的时候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。</span></span><br><span class="line">    <span class="comment">// 这个顺序不能倒，pair排序时是先根据first，再根据second，</span></span><br><span class="line">     <span class="comment">// 这里显然要根据距离排序,对pair排序默认先对first,所以first放距离更省事 </span></span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap;</span><br><span class="line">	heap.<span class="built_in">push</span>({<span class="number">0</span>,<span class="number">1</span>});</span><br><span class="line">	<span class="keyword">while</span>(heap.<span class="built_in">size</span>()){</span><br><span class="line">		<span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">		heap.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> distance = t.first,node = t.second;</span><br><span class="line">		<span class="keyword">if</span>(st[node])<span class="keyword">continue</span>;</span><br><span class="line">		st[node] = <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[node].<span class="built_in">size</span>(); i ++){</span><br><span class="line">			<span class="type">int</span> newNode = G[node][i].first;</span><br><span class="line">			<span class="type">int</span> len = G[node][i].second;</span><br><span class="line">			<span class="keyword">if</span>(dist[newNode]&gt;dist[node] + len){</span><br><span class="line">				dist[newNode] = dist[node] + len;</span><br><span class="line">				heap.<span class="built_in">push</span>({dist[newNode],newNode});</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	G.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++){</span><br><span class="line">		<span class="type">int</span> x,y,z;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">		G[x].<span class="built_in">push_back</span>({y,z});</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; <span class="built_in">dijkstra</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h6 id="最短路径-和-各种第二标量"><a href="#最短路径-和-各种第二标量" class="headerlink" title="最短路径 和 各种第二标量"></a>最短路径 和 各种第二标量</h6><p>例题PTA甲级 <strong>紧急事件</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> G[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="type">int</span> dist[<span class="number">510</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">510</span>];<span class="comment">//救援队</span></span><br><span class="line"><span class="type">int</span> n,m,c1,c2;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">510</span>];</span><br><span class="line"><span class="type">int</span> weight[<span class="number">510</span>];</span><br><span class="line"><span class="type">int</span> num2[<span class="number">510</span>];<span class="comment">//最短路数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[c1] = <span class="number">0</span>;</span><br><span class="line">    num2[c1] = <span class="number">1</span>;</span><br><span class="line">    num[c1] = weight[c1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; i ++){</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++){</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;(t==<span class="number">-1</span>||dist[t] &gt;dist[j])){</span><br><span class="line">                t = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        vis[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++){</span><br><span class="line">            <span class="comment">// dist[j] = min(dist[j],dist[t] + G[t][j]);</span></span><br><span class="line">            <span class="keyword">if</span>(dist[t] + G[t][j] &lt; dist[j]){</span><br><span class="line">                dist[j] = dist[t] + G[t][j];</span><br><span class="line">                num[j] = num[t] + weight[j];</span><br><span class="line">                num2[j] = num2[t];</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(dist[t] +G[t][j] == dist[j]){</span><br><span class="line">            num2[j] += num2[t];</span><br><span class="line">            <span class="keyword">if</span>(weight[j] + num[t] &gt; num[j])</span><br><span class="line">            num[j] = num[t] + weight[j];</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; num2[c2] &lt;&lt;<span class="string">" "</span>&lt;&lt;num[c2];</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin &gt;&gt;n &gt;&gt; m &gt;&gt;c1&gt;&gt;c2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++){</span><br><span class="line">        cin &gt;&gt; weight[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">memset</span>(G,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> G);</span><br><span class="line">    <span class="keyword">while</span>(m --){</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        G[x][y] = <span class="built_in">min</span>(G[x][y],z);</span><br><span class="line">        G[y][x] = <span class="built_in">min</span>(G[y][x],z);</span><br><span class="line">        <span class="comment">// G[x][y] = G[y][x]= z;</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>书P375</p>
<h6 id="打印路径"><a href="#打印路径" class="headerlink" title="打印路径"></a>打印路径</h6><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> v)</span></span>{ <span class="comment">//s是起点编号，v是当前访问的顶点编号(从终点开始递归)</span></span><br><span class="line">	<span class="keyword">if</span>(v == s){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">DFS</span>(s,pre[v]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,v);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为什么无法处理负边</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/6320/%E8%AF%A6%E8%A7%A3%E5%BE%88%E5%A5%BD">https://www.acwing.com/solution/content/6320/详解很好</a></p>
<h6 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman-ford"></a>bellman-ford</h6><p><strong>与spfa比可能唯一的好处：如果是有边数限制的话，就不能用spfa了</strong></p>
<p>时间复杂度 N*M</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%B4%9F%E6%9D%83%E5%9B%9E%E8%B7%AF.png"></p>
<p>如果有负权回路的话，最短路不一定存在了</p>
<p><strong>bellman-ford是可以求出是否有负环的,但平时不用，时间复杂度太高，后面SPFA会用到</strong></p>
<p><strong>鸽巢（抽屉）原理</strong></p>
<h6 id="Spfa"><a href="#Spfa" class="headerlink" title="Spfa"></a>Spfa</h6><h5 id="多源汇最短路"><a href="#多源汇最短路" class="headerlink" title="多源汇最短路"></a>多源汇最短路</h5><h6 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h6><h2 id="4-第四章-数学知识（12-10）"><a href="#4-第四章-数学知识（12-10）" class="headerlink" title="4.第四章 数学知识（12.10）"></a>4.第四章 数学知识（12.10）</h2><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p><strong>（要很熟练）</strong></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2.png"></p>
<p>转换成10进制用的秦九韶算法，迭代方式提升效率</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>洛谷 P1469 找筷子</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%89%BE%E7%AD%B7%E5%AD%90%E9%A2%98%E8%A7%A3.png"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//交换律 结合律 把偶数的先结合成0，最后只剩落单的和0异或还是它自己</span></span><br><span class="line"><span class="type">int</span> ans,n,a;<span class="comment">//ans是所有数异或之后的结果，也就是题目所求的落单的筷子的数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	{</span><br><span class="line">   	  	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">		ans^=a;<span class="comment">//把所有的数都异或起来</span></span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="加法原理与乘法原理"><a href="#加法原理与乘法原理" class="headerlink" title="加法原理与乘法原理"></a>加法原理与乘法原理</h3><p>结果可能很大，要对指定数字取余数。不能全部乘完之后再取余数，因为中间结果可能会溢出。可以乘完一次就取一次余数。实际上，加法或者乘法都可以这样做：</p>
<p>(a+b+c)%k = ((a+b)%k + c)%k</p>
<p>(a * b * c) % k = ((a<em>b)%k * c</em>)%k</p>
<h3 id="组合数问题"><a href="#组合数问题" class="headerlink" title="组合数问题"></a>组合数问题</h3><p>例题</p>
<p><strong>洛谷 P2822 [NOIP2016 提高组] 组合数问题</strong></p>
<p>| 同余定理，前面是除数，后面是被除数</p>
<p>杨辉三角的性质</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c[<span class="number">2010</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="type">int</span> t,k,m,n;</span><br><span class="line">	cin &gt;&gt; t &gt;&gt; k;</span><br><span class="line">	<span class="comment">//先设置一个杨辉三角</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2000</span>; i ++){</span><br><span class="line">		c[i][<span class="number">0</span>] = c[i][i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j= <span class="number">1</span>; j &lt; i ; j ++)</span><br><span class="line">            <span class="comment">//加法计算可以在途中取余</span></span><br><span class="line">			c[i][j] = (c[i<span class="number">-1</span>][j] + c[i<span class="number">-1</span>][j<span class="number">-1</span>])%k;</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">		<span class="keyword">while</span>(t--){</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(i,m); j ++)</span><br><span class="line">					ans+=c[i][j] == <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">			cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">		}	</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BA%A6%E6%95%B0.png"></p>
<p>例题 P2926 [USACO08DEC] Patting Heads S</p>
<p>未解决</p>
<h4 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h4><h4 id="约数个数和约数之和-两个公式"><a href="#约数个数和约数之和-两个公式" class="headerlink" title="约数个数和约数之和(两个公式)"></a>约数个数和约数之和(两个公式)</h4><h4 id="约数个数证明："><a href="#约数个数证明：" class="headerlink" title="约数个数证明："></a>约数个数证明：</h4><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E8%AF%81%E6%98%8E.png"></p>
<h3 id="质数和合数"><a href="#质数和合数" class="headerlink" title="质数和合数"></a>质数和合数</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/TpeterH/article/details/115891290">所以，在以后的算法学习中，大家可以有意识地去使用线性筛进行解题，防止白给。除了这两种筛素数的方法，其实还有更加优秀的，时间复杂度低于O(N)的筛法，这里本人能力有限，就不进行介绍了，有兴趣的同学可以自己去查找相关资料。</a></p>
<h4 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes1</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">if</span>(!st[i]){</span><br><span class="line">            primes[cnt++]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i) st[j]=<span class="literal">true</span>;<span class="comment">//可以用质数就把所有的合数都筛掉；</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//primes数组用来存放质数</span></span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="comment">//st[i], i为质数则为false否则为true</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes[cnt++] = i;</span><br><span class="line">        <span class="comment">//假设primes[0]为n最小的质因子,i为最大的因数，</span></span><br><span class="line">        <span class="comment">//易知若primes[i]中i&gt;0,则会进入循环后产生多余的标记。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//标记;primes[j]一定是primes[j]*i的最小质因子</span></span><br><span class="line">            st[primes[j]*i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//表明primes[j]一定是i的最小质因子,没有必要再遍历,primes要小于等于i的最小质因子</span></span><br><span class="line">            <span class="comment">//这样能保证每个数遍历一遍,而没有重复</span></span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52072919/article/details/116400820?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%BF%AB%E9%80%9F%E5%B9%82&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-116400820.nonecase&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/m0_52072919/article/details/116400820?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%BF%AB%E9%80%9F%E5%B9%82&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-116400820.nonecase&amp;spm=1018.2226.3001.4187</a></p>
<p>这个博客很好</p>
<p>模板</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/877/">https://www.acwing.com/problem/content/description/877/</a></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> base, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> power, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> result = <span class="number">1</span>;   </span><br><span class="line">	<span class="keyword">while</span> (power &gt; <span class="number">0</span>)           </span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (power &amp; <span class="number">1</span>)         							</span><br><span class="line">			result = result * base % p;   </span><br><span class="line">			<span class="comment">//根据公式每个项都取余数后在再做累乘</span></span><br><span class="line">		base = base * base % p ;   </span><br><span class="line">			<span class="comment">//根据公式每个项都取余数后在再做平方操作      						</span></span><br><span class="line">		power &gt;&gt;= <span class="number">1</span>;         						</span><br><span class="line">	}</span><br><span class="line">			<span class="comment">//根据公式在最后的的结果上再来一次取余数</span></span><br><span class="line">	<span class="keyword">return</span> result % p;       </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --){</span><br><span class="line">        <span class="type">int</span> base,power,p;</span><br><span class="line">        cin &gt;&gt; base &gt;&gt; power &gt;&gt; p;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">qmi</span>(base,power,p)&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%BF%AB%E9%80%9F%E5%B9%82.png"></p>
<p><strong>n mod 2可以写成n &amp; 1, n/2 可以写成 n &gt;&gt; 1</strong></p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%BA%94%E7%94%A8.png"></p>
<h2 id="5-第五章-动态规划（待更）"><a href="#5-第五章-动态规划（待更）" class="headerlink" title="5.第五章 动态规划（待更）"></a>5.第五章 动态规划（待更）</h2><p>重复调用的问题适合改动态规划</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BB%BB%E4%BD%95dp%E9%83%BD%E8%83%BD%E4%BB%8E%E9%80%92%E5%BD%92%E5%85%A5%E6%89%8B.png"></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BB%8E%E9%80%92%E5%BD%92%E5%85%A5%E6%89%8B%E4%B8%80%E7%BB%B4dp.png"></p>
<h3 id="斐波那契数列优化"><a href="#斐波那契数列优化" class="headerlink" title="斐波那契数列优化"></a>斐波那契数列优化</h3><p>1.递归</p>
<p>2.记忆化</p>
<p>3.dp</p>
<p>4.使用两个变量</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/dp%E6%B5%81%E7%A8%8B.png"></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/dp%E5%85%A5%E9%97%A8.png"></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/dp%E5%85%A5%E9%97%A8%E6%80%9D%E8%B7%AF.png"></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%86%99%E5%87%BA%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95.png"></p>
<p><strong>动态规划就是递推的子集</strong></p>
<p><strong>例题</strong></p>
<p><img src="/../../../../../CS/%E7%AC%94%E8%AE%B0/acwing%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/dp%E4%BE%8B%E9%A2%98.png" alt="image-20231221194259987"></p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h4><p>一维 01 逆序，完全 正序</p>
<h4 id="记化化搜索"><a href="#记化化搜索" class="headerlink" title="记化化搜索"></a>记化化搜索</h4><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%83%8C%E5%8C%85%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2.png"></p>
<h4 id="二维DP"><a href="#二维DP" class="headerlink" title="二维DP"></a>二维DP</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> v[MAXN];    <span class="comment">// 体积</span></span><br><span class="line"><span class="type">int</span> w[MAXN];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN];  <span class="comment">// f[i][j], j体积下前i个物品的最大价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n, m;   </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//  当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// 能装，需进行决策是否选择第i个物品</span></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        }           </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="滚动数组（优化成一维DP）版本"><a href="#滚动数组（优化成一维DP）版本" class="headerlink" title="滚动数组（优化成一维DP）版本"></a>滚动数组（优化成一维DP）版本</h4><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/01%E4%B8%80%E7%BB%B4.png"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    <span class="comment">//这里如果从0~m的话，可能会用到上层被这层覆盖的值</span></span><br><span class="line">   <span class="comment">//可以自己画表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];  <span class="comment">// 优化前</span></span><br><span class="line">            f[j] = f[j];            <span class="comment">// 优化后，该行自动成立，可省略。</span></span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);  <span class="comment">// 优化前</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);                   <span class="comment">// 优化后</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><h5 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h5><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E4%BA%8C%E7%BB%B4.png"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> N,V;</span><br><span class="line"><span class="type">int</span> v[P],w[P];</span><br><span class="line"><span class="type">int</span> mm[P][P];</span><br><span class="line"><span class="comment">// int dfs(int x,int spV){</span></span><br><span class="line"><span class="comment">//     if(x &gt; N || spV &lt; 0)mm[x][spV] = 0;</span></span><br><span class="line"><span class="comment">//     else if(spV &lt; v[x]) mm[x][spV]=dfs(x+1,spV);</span></span><br><span class="line"><span class="comment">//   return mm[x][spV];</span></span><br><span class="line"><span class="comment">//             else mm[x][spV] = max(dfs(x + 1,spV),dfs(x,spV-v[x])+w[x]);</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i ++){</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// int res = dfs(1,V);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i ++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= V; j ++){</span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i])mm[i][j] = mm[i - <span class="number">1</span>][j];</span><br><span class="line">    <span class="keyword">else</span> mm[i][j] = <span class="built_in">max</span>(mm[i - <span class="number">1</span>][j],mm[i][j - v[i]]+ w[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; mm[N][V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维正序枚举，下面的写法不舒服，可以把上面的改成正序的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ;i ++)</span><br><span class="line">    {</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j&lt;=m ;j++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span> ; k*v[i]&lt;=j ; k++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h5><p>可以画图，体积从正序枚举是对的，每个物品可以无限取，从倒序枚举是错的，不然和01（只能取一次）一样了，画个图就ok</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E4%B8%80%E7%BB%B4.png"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ;i ++)</span><br><span class="line">    {</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)</span><br><span class="line">    <span class="comment">//j小于v[i]的不改变</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = v[i] ; j&lt;=m ;j++)</span><br><span class="line">{</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">}</span><br><span class="line">	cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h4><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.png"></p>
<p> 多重背包问题 I (数据范围100，n^3没超1e7-1e8)</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/4/">https://www.acwing.com/problem/content/4/</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++){<span class="comment">//枚举背包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++){<span class="comment">//枚举体积</span></span><br><span class="line">        <span class="comment">//k从0开始，可能一个都不选</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i]; k ++){</span><br><span class="line">            <span class="keyword">if</span>(j &gt;=  k * v[i]){</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>多重背包问题 II (正常做会超)</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/5/">https://www.acwing.com/problem/content/5/</a></p>
<p>分组背包</p>
<h5 id="二维-1"><a href="#二维-1" class="headerlink" title="二维"></a>二维</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];  <span class="comment">//只从前i组物品中选，当前体积小于等于j的最大值</span></span><br><span class="line"><span class="type">int</span> v[N][N],w[N][N],s[N];   <span class="comment">//v为体积，w为价值，s代表第i组物品的个数</span></span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s[i];j++){</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];  <span class="comment">//读入</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++){</span><br><span class="line">        f[i][j]=f[i<span class="number">-1</span>][j];  <span class="comment">//不选</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;s[i];k++){</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i][k])     f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);  </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="一维-1"><a href="#一维-1" class="headerlink" title="一维"></a>一维</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">因为只用到了第i<span class="number">-1</span>列，所以可以仿照<span class="number">01</span>背包的套路逆向枚举体积</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N][N],w[N][N],s[N];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s[i];j++){</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;s[i];k++){    <span class="comment">//for(int k=s[i];k&gt;=1;k--)也可以</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i][k])     f[j]=<span class="built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);  </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h4><p><strong>例题 洛谷 1130红牌</strong></p>
<p>例题  <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/8/">https://www.acwing.com/problem/content/description/8/</a></p>
<h4 id="背包问题的变种"><a href="#背包问题的变种" class="headerlink" title="背包问题的变种"></a>背包问题的变种</h4><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%98%E7%A7%8D.png"></p>
<h5 id="01背包求方案数"><a href="#01背包求方案数" class="headerlink" title="01背包求方案数"></a>01背包求方案数</h5><p><strong>例题 acwing278. 数字组合</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="comment">/*int dfs(int u,int spSum){</span></span><br><span class="line"><span class="comment">	if(f[u][spSum]!=0)return f[u][spSum];</span></span><br><span class="line"><span class="comment">	else if(spSum != 0 &amp;&amp; u &gt; n)f[u][spSum] = 0;</span></span><br><span class="line"><span class="comment">	else if(spSum &lt; 0)f[u][spSum] = 0;</span></span><br><span class="line"><span class="comment">	else if(spSum == 0)f[u][spSum] = 1;</span></span><br><span class="line"><span class="comment">	else f[u][spSum] = dfs(u +1,spSum) + dfs(u + 1,spSum - a[u]);</span></span><br><span class="line"><span class="comment">	return f[u][spSum];</span></span><br><span class="line"><span class="comment">}*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n &gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++){</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n+<span class="number">1</span>; i++) {</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 当和为0时，方案数为1</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) {</span><br><span class="line">            f[i][j] = f[i + <span class="number">1</span>][j];  <span class="comment">// 不选择第i个数</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= a[i]) {</span><br><span class="line">                f[i][j] += f[i + <span class="number">1</span>][j - a[i]];  <span class="comment">// 选择第i个数</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][m];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h5 id="01背包求具体方案"><a href="#01背包求具体方案" class="headerlink" title="01背包求具体方案"></a>01背包求具体方案</h5><p>为什么逆序枚举？</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/12/">https://www.acwing.com/problem/content/description/12/</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yl_puyu/article/details/109960323%E8%A7%A3%E9%87%8A%E5%BE%88%E5%A5%BD">https://blog.csdn.net/yl_puyu/article/details/109960323解释很好</a></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) {</span><br><span class="line">            f[i][j] = f[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i + <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在此，f[1][m]就是最大数量</span></span><br><span class="line">    <span class="type">int</span> j = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        <span class="keyword">if</span> (j &gt;= v[i] &amp;&amp; f[i][j] == f[i + <span class="number">1</span>][j - v[i]] + w[i]) {</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            j -= v[i];</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="01背包求最优方案数"><a href="#01背包求最优方案数" class="headerlink" title="01背包求最优方案数"></a>01背包求最优方案数</h5><p>背包例题</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/paste/s2v5pn69">https://www.luogu.com.cn/paste/s2v5pn69</a></p>
<p>洛谷P1802 5倍经验日（01背包变<strong>形问题）</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">这是一道变了形的<span class="number">01</span>背包</span><br><span class="line"></span><br><span class="line">首先我们因为和每个人打都一定有经验所以一定都要打一遍。</span><br><span class="line"></span><br><span class="line">所以不难想到max=lose[<span class="number">1</span>]+lose[<span class="number">2</span>]......+lose[n]+某些磕了药打赢的多出的经验值</span><br><span class="line"></span><br><span class="line">因此我们可以进行一个转换，把价值记为win[i]-lose[i]，溶剂就是要打赢磕的药，然后要使价值总和最大，然后就变成了基础的零一背包了。。。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> win[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> lose[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;lose[i],&amp;win[i],&amp;v[i]);</span><br><span class="line">        a[i]=win[i]-lose[i];</span><br><span class="line">        sum=sum+lose[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=m;j&gt;=v[i];j--){</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+a[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,<span class="number">5</span>*(f[m]+sum));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%A1%E7%89%B9%E5%85%B0%E9%80%9A%E9%A1%B9.png"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/lWYCzv/">https://leetcode.cn/circle/discuss/lWYCzv/</a></p>
<p><strong>例题1 进出栈序列</strong></p>
<h3 id="线性DP经典例题（待更）"><a href="#线性DP经典例题（待更）" class="headerlink" title="线性DP经典例题（待更）"></a>线性DP经典例题（待更）</h3><h3 id="图上动态规划（待更）"><a href="#图上动态规划（待更）" class="headerlink" title="图上动态规划（待更）"></a>图上动态规划（待更）</h3></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>自用算法笔记(持续更新)</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://jiazixin.xyz/2023/12/26/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">http://jiazixin.xyz/2023/12/26/自用算法笔记/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display: inline-block;width: 120px"><h>作者</h><div class="post-copyright-cc-info"><h>contito</h></div></div><div class="post-copyright-c" style="display: inline-block;width: 120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-12-26</h></div></div><div class="post-copyright-u" style="display: inline-block;width: 120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-12-30</h></div></div><div class="post-copyright-c" style="display: inline-block;width: 120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E5%90%91/">算法(刷题向)</a></div><div class="post_share"><div class="social-share" data-image="/img/%E5%A3%81%E7%BA%B8/%E5%AD%A4%E7%8B%AC%E6%91%87%E6%BB%9A01.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/%E5%BE%AE%E4%BF%A1.png" target="_blank"><img class="post-qr-code-img" src="/img/%E5%BE%AE%E4%BF%A1.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/%E6%94%AF%E4%BB%98%E5%AE%9D.jpg" target="_blank"><img class="post-qr-code-img" src="/img/%E6%94%AF%E4%BB%98%E5%AE%9D.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/01/01/Codeforces/" title="codeforces(日更)"><img class="cover" src="/img/%E5%A3%81%E7%BA%B8/cf.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">codeforces(日更)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/01/01/Codeforces/" title="codeforces(日更)"><img class="cover" src="/img/%E5%A3%81%E7%BA%B8/cf.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-01</div><div class="title">codeforces(日更)</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/%E9%99%B6%E5%96%86%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">contito</div><div class="author-info__description">看到我请让我滚去学习</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">&lt;建站时间2023.12.28&gt;2024,加油</div></div><div class="card-widget card-calendar"><div class="card-content"><div class="item-headline"><i class="fas fa-calendar"></i><span>文章日历</span></div><div class="widget" id="calendar"></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">算法笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">1.第一章 基础算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.1.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E9%87%8F%E7%8C%9C%E8%A7%A3%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">根据数据量猜解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.4.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">例题 逆序对</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%B2%BB"><span class="toc-number">1.1.5.</span> <span class="toc-text">分治</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.6.</span> <span class="toc-text">计数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.7.</span> <span class="toc-text">桶排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86"><span class="toc-number">1.1.8.</span> <span class="toc-text">二分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%EF%BC%8810-15-10-17-11-13%EF%BC%89"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">二分答案（10.15-10.17 11.13）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Elower-bound-%E5%92%8Cupper-bound-%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">关于lower_bound( )和upper_bound( )的常见用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%88%E7%95%A5%E8%BF%87%EF%BC%89"><span class="toc-number">1.1.9.</span> <span class="toc-text">高精度（略过）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C-%E5%92%8C-%E5%B7%AE%E5%88%86"><span class="toc-number">1.1.10.</span> <span class="toc-text">前缀和 和 差分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97-%E5%BE%85%E6%9B%B4"><span class="toc-number">1.1.11.</span> <span class="toc-text">位运算(待更)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-number">1.1.12.</span> <span class="toc-text">离散化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="toc-number">1.1.13.</span> <span class="toc-text">区间合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">2.第二章 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">链表和邻接表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">双链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">邻接表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.2.2.</span> <span class="toc-text">栈和队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%882023-12-15%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">单调栈（2023.12.15）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">1.2.4.</span> <span class="toc-text">单调队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kmp%E7%AE%97%E6%B3%95%EF%BC%88%E7%95%A5%EF%BC%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">kmp算法（略）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trie"><span class="toc-number">1.2.6.</span> <span class="toc-text">Trie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-12-8"><span class="toc-number">1.2.7.</span> <span class="toc-text">并查集(12.8)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%EF%BC%8812-19%EF%BC%89"><span class="toc-number">1.2.8.</span> <span class="toc-text">堆（12.19）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.2.9.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.10.</span> <span class="toc-text">树状数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-%E5%8A%A8%E6%80%81%E6%B1%82%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="toc-number">1.2.10.0.1.</span> <span class="toc-text">例题 动态求区间和</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-1"><span class="toc-number">1.2.10.0.1.1.</span> <span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%99%E9%81%93%E9%A2%98%E7%9A%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.10.0.1.2.</span> <span class="toc-text">这道题的线段树方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E5%80%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.2.10.0.1.3.</span> <span class="toc-text">4倍空间的原因</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E4%BE%8B%E9%A2%98-%E6%B4%9B%E8%B0%B7P3368"><span class="toc-number">1.2.10.0.2.</span> <span class="toc-text">区间求和例题:洛谷P3368</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%BE%85%E6%9B%B4"><span class="toc-number">1.2.11.</span> <span class="toc-text">线段树(待更)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA"><span class="toc-number">1.3.</span> <span class="toc-text">3.第三章 搜索与图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS"><span class="toc-number">1.3.1.</span> <span class="toc-text">深度优先搜索(DFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS"><span class="toc-number">1.3.2.</span> <span class="toc-text">广度优先搜索(BFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%8810-21%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">树与图的存储（10.21）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">树与图的深度优先遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-%E5%BE%85%E6%9B%B4"><span class="toc-number">1.3.5.</span> <span class="toc-text">树与图的宽度优先遍历(待更)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DAG-%E4%B8%8E-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%8812-4%EF%BC%89"><span class="toc-number">1.3.6.</span> <span class="toc-text">DAG() 与 拓扑排序（12.4）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.3.7.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9B%E6%89%A3%E6%80%BB%E7%BB%93%E7%B2%BE%E5%8D%8E"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">力扣总结精华</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.3.7.1.1.</span> <span class="toc-text">带权单源最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Dijkstra"><span class="toc-number">1.3.7.1.1.1.</span> <span class="toc-text">Dijkstra</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E7%89%88"><span class="toc-number">1.3.7.1.1.2.</span> <span class="toc-text">朴素版</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88"><span class="toc-number">1.3.7.1.1.3.</span> <span class="toc-text">堆优化版</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E5%92%8C-%E5%90%84%E7%A7%8D%E7%AC%AC%E4%BA%8C%E6%A0%87%E9%87%8F"><span class="toc-number">1.3.7.1.1.4.</span> <span class="toc-text">最短路径 和 各种第二标量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84"><span class="toc-number">1.3.7.1.1.5.</span> <span class="toc-text">打印路径</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#bellman-ford"><span class="toc-number">1.3.7.1.1.6.</span> <span class="toc-text">bellman-ford</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Spfa"><span class="toc-number">1.3.7.1.1.7.</span> <span class="toc-text">Spfa</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%BA%90%E6%B1%87%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.3.7.1.2.</span> <span class="toc-text">多源汇最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Floyd"><span class="toc-number">1.3.7.1.2.1.</span> <span class="toc-text">Floyd</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%8812-10%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">4.第四章 数学知识（12.10）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.1.</span> <span class="toc-text">进制转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.2.</span> <span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E4%B9%98%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.3.</span> <span class="toc-text">加法原理与乘法原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.4.</span> <span class="toc-text">组合数问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%95%B0"><span class="toc-number">1.4.5.</span> <span class="toc-text">约数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%95%E9%99%A4%E6%B3%95%E6%B1%82%E7%BA%A6%E6%95%B0"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">试除法求约数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C-%E4%B8%A4%E4%B8%AA%E5%85%AC%E5%BC%8F"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">约数个数和约数之和(两个公式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E8%AF%81%E6%98%8E%EF%BC%9A"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">约数个数证明：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A8%E6%95%B0%E5%92%8C%E5%90%88%E6%95%B0"><span class="toc-number">1.4.6.</span> <span class="toc-text">质数和合数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%83%E6%B0%8F%E7%AD%9B"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">埃氏筛</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%AD%9B"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">线性筛</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">1.4.7.</span> <span class="toc-text">快速幂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%BE%85%E6%9B%B4%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">5.第五章 动态规划（待更）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.1.</span> <span class="toc-text">斐波那契数列优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.2.</span> <span class="toc-text">背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">01背包问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%8C%96%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">记化化搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4DP"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">二维DP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%EF%BC%88%E4%BC%98%E5%8C%96%E6%88%90%E4%B8%80%E7%BB%B4DP%EF%BC%89%E7%89%88%E6%9C%AC"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">滚动数组（优化成一维DP）版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">完全背包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4"><span class="toc-number">1.5.2.5.1.</span> <span class="toc-text">二维</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4"><span class="toc-number">1.5.2.5.2.</span> <span class="toc-text">一维</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">多重背包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4-1"><span class="toc-number">1.5.2.6.1.</span> <span class="toc-text">二维</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4-1"><span class="toc-number">1.5.2.6.2.</span> <span class="toc-text">一维</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">二维费用背包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%98%E7%A7%8D"><span class="toc-number">1.5.2.8.</span> <span class="toc-text">背包问题的变种</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85%E6%B1%82%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">1.5.2.8.1.</span> <span class="toc-text">01背包求方案数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85%E6%B1%82%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88"><span class="toc-number">1.5.2.8.2.</span> <span class="toc-text">01背包求具体方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85%E6%B1%82%E6%9C%80%E4%BC%98%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">1.5.2.8.3.</span> <span class="toc-text">01背包求最优方案数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0"><span class="toc-number">1.5.3.</span> <span class="toc-text">卡特兰数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7DP%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98%EF%BC%88%E5%BE%85%E6%9B%B4%EF%BC%89"><span class="toc-number">1.5.4.</span> <span class="toc-text">线性DP经典例题（待更）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E4%B8%8A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%BE%85%E6%9B%B4%EF%BC%89"><span class="toc-number">1.5.5.</span> <span class="toc-text">图上动态规划（待更）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/01/Codeforces/" title="codeforces(日更)"><img src="/img/%E5%A3%81%E7%BA%B8/cf.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="codeforces(日更)"></a><div class="content"><a class="title" href="/2024/01/01/Codeforces/" title="codeforces(日更)">codeforces(日更)</a><time datetime="2024-01-01T13:15:28.324Z" title="发表于 2024-01-01 21:15:28">2024-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/26/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="自用算法笔记(持续更新)"><img src="/img/%E5%A3%81%E7%BA%B8/%E5%AD%A4%E7%8B%AC%E6%91%87%E6%BB%9A01.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自用算法笔记(持续更新)"></a><div class="content"><a class="title" href="/2023/12/26/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="自用算法笔记(持续更新)">自用算法笔记(持续更新)</a><time datetime="2023-12-26T14:51:20.737Z" title="发表于 2023-12-26 22:51:20">2023-12-26</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2023 - 2024 By contito</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><div class="aplayer no-destroy" data-id="150430" data-server="netease" data-type="song" data-fixed="true" data-autoplay="true"> </div><script src="//npm.elemecdn.com/leancloud-storage@4.13.1/dist/av-min.js"></script><canvas id="universe"></canvas><script defer="" src="/js/universe.js"></script><script type="text/javascript" src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="/js/languages.js"></script><script data-pjax="" type="text/javascript" src="/js/calendar.js"></script><script type="text/javascript" src="/js/dianzan.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>