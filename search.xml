<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2024/02/28/CF%E6%9D%BF%E5%88%B7/</url>
    <content><![CDATA[<p>1200 板刷20题</p>
<p>1.<a href="https://www.luogu.com.cn/problem/CF466A">https://www.luogu.com.cn/problem/CF466A</a> 模拟</p>
<p>2.<a href="https://www.luogu.com.cn/problem/CF1352C">https://www.luogu.com.cn/problem/CF1352C</a> （推公式题）第k个不能整除n数</p>
<p>3.<a href="https://www.luogu.com.cn/problem/CF489B">https://www.luogu.com.cn/problem/CF489B</a> 哈希</p>
<p>4、<a href="https://www.luogu.com.cn/problem/CF514A">https://www.luogu.com.cn/problem/CF514A</a> 模拟，注意前导0</p>
<p>5.<a href="https://www.luogu.com.cn/problem/CF474B">https://www.luogu.com.cn/problem/CF474B</a> 二分</p>
<p>6.<a href="https://www.luogu.com.cn/problem/solution/CF1520D">https://www.luogu.com.cn/problem/solution/CF1520D</a> map桶统计</p>
<p>7.<a href="https://codeforces.com/problemset/problem/327/A">https://codeforces.com/problemset/problem/327/A</a> 注意数据范围，可以暴力就可以考虑</p>
<p>8.<a href="https://www.luogu.com.cn/problem/CF1343C">https://www.luogu.com.cn/problem/CF1343C</a> 这题太好，把每块相同符号的最大值选出来，遇到不同符号的加上之前迭代得到的max，题解也有用dp（最长上升子序列模型）的</p>
<p>9.<a href="https://codeforces.com/problemset/problem/433/B">https://codeforces.com/problemset/problem/433/B</a></p>
<p>感觉差不多了，刷1300</p>
<p>1300 板刷30题</p>
<p>1.<a href="https://www.luogu.com.cn/problem/CF4C">https://www.luogu.com.cn/problem/CF4C</a> stl map最基本使用</p>
<p>2.<a href="https://www.luogu.com.cn/problem/CF230B">https://www.luogu.com.cn/problem/CF230B</a> 要判断一下这个数的平方根是否为质数就OK了(我原来直接判断这个数是不是质数，但是完全多余，会超时，)</p>
<p><a href="https://www.luogu.com.cn/problem/CF189A">https://www.luogu.com.cn/problem/CF189A</a> 完全背包，没看懂</p>
<p><a href="https://www.luogu.com.cn/problem/CF451B%E5%BE%88%E5%A5%BD%E7%9A%84%E4%B8%80%E9%81%93%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%8B%9F%E9%A2%98">https://www.luogu.com.cn/problem/CF451B很好的一道排序模拟题</a></p>
<p>1400 板刷50题</p>
]]></content>
  </entry>
  <entry>
    <title>linux(持续更新)</title>
    <url>/2024/01/02/Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h3 id="概述📚"><a href="#概述📚" class="headerlink" title="概述📚"></a>概述📚</h3><p>一个OS，最底层的软件，是跟Windows和macOS并驾齐驱的一个OS。Linus Torvalds基于开源的Minux上面做改进，最后发现不如重写一个—Linux，并且公开源代码。</p>
<p>Unix(早期开源，后来商业化后不开源) -&gt; Minix(Unix的变种 开源) -&gt; Linux</p>
<p><img src="/img/linux/01.png"></p>
<p><em>Unix诞生后，由于用汇编开发过于麻烦，Unix创造者又要发明高级语言，第一次B语言，效果不好失败了，然后又发明new B（大神的乐趣），取名<strong>C语言</strong>。</em></p>
<h4 id="GNU-Linux🐱‍🏍"><a href="#GNU-Linux🐱‍🏍" class="headerlink" title="GNU&#x2F;Linux🐱‍🏍"></a>GNU&#x2F;Linux🐱‍🏍</h4><p>简要介绍 Linux 内核、Linux 系统和 GNU 工具。</p>
<ol>
<li>Linux 内核：<ul>
<li>Linux 内核是操作系统的核心组件，它是一个开源的、免费的、可移植的操作系统内核。它由芬兰计算机科学家 Linus Torvalds 在 1991 年创建，并在全球范围内得到了广泛的开发和贡献。</li>
<li>Linux 内核负责管理计算机的硬件资源，如处理器、内存、设备驱动程序和文件系统等。它提供了一个稳定的、安全的和高性能的运行环境，让应用程序和用户能够与计算机系统进行交互。</li>
<li>Linux 内核采用了模块化的设计，可以根据需要加载和卸载不同的模块，从而支持广泛的硬件设备和功能。</li>
</ul>
</li>
<li>Linux 系统：<ul>
<li>Linux 系统指的是基于 Linux 内核的操作系统。它是一个完整的操作系统，包括了 Linux 内核和其他一系列的软件和工具，以提供完整的计算机操作环境。</li>
<li>Linux 系统提供了许多功能和特性，如多任务处理、多用户支持、网络通信、文件管理和安全性等。它也支持各种应用程序和开发工具，可以运行服务器、个人计算机、嵌入式设备和移动设备等不同类型的硬件平台。</li>
</ul>
</li>
<li>GNU 工具：<ul>
<li>GNU 是一个自由软件项目，旨在开发一套完全自由的操作系统。GNU 代表 “GNU’s Not Unix”，它的目标是创建一个类似于 Unix 的操作系统，但完全由自由软件组成。</li>
<li>GNU 工具是 GNU 项目开发的一套软件工具集，包括编译器、调试器、文本编辑器、Shell 等。这些工具为 Linux 系统提供了基本的用户界面和开发环境。</li>
<li>GNU 工具中最著名的组件是 GCC（GNU Compiler Collection），它是一个功能强大的编译器套件，支持多种编程语言，如 C、C++、Fortran 和 Ada 等。</li>
</ul>
</li>
</ol>
<p>综上所述，Linux 包括了 Linux 内核和 GNU 工具，它们共同构成了一个功能强大的、免费的、开源的操作系统。Linux 内核负责管理硬件和提供核心功能，而 GNU 工具提供了用户界面、开发环境和其他实用工具。这使得 Linux 成为一种受欢迎的操作系统，并被广泛用于各种计算机和设备。</p>
<h4 id="用处🐱‍🏍"><a href="#用处🐱‍🏍" class="headerlink" title="用处🐱‍🏍"></a>用处🐱‍🏍</h4><p>学习Linux可以做运维工程师（系统运维、应用运维、DBA）、开发工程师(内核&#x2F;驱动开发、基于linux的软件开发、嵌入式开发(偏底层，用C&#x2F;C++))，从行业上来讲，后台开发如java开发、数据库开发，物联网开发、架构师都要懂linux，大数据、云计算这种面对服务器集群的行业更需要。可以认为是<strong>高级程序员必备技能</strong></p>
<p>我们安装的都是广义的linux，多了命令解释层和外围应用层</p>
<p><img src="/img/linux/02.png"></p>
<p><img src="/img/linux/04.png"></p>
<p>客户端Android系统，国产操作系统deepin也可作了解</p>
<h4 id="linux和windows区别🐱‍🏍"><a href="#linux和windows区别🐱‍🏍" class="headerlink" title="linux和windows区别🐱‍🏍"></a>linux和windows区别🐱‍🏍</h4><p><img src="/img/linux/03.png"></p>
<h3 id="安装步骤👔"><a href="#安装步骤👔" class="headerlink" title="安装步骤👔"></a>安装步骤👔</h3><p><em>先比较一下centos和ubuntu</em></p>
<p><img src="/img/linux/05.png"></p>
<ol>
<li><strong>centOS</strong>下载地址<a href="https://centos.org/download/">https://centos.org/download/</a></li>
<li>下载7.9版本，使用阿里云镜像<a href="https://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/">https://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/</a></li>
<li>选择标准版</li>
<li><img src="/img/linux/06.png"></li>
<li>使用VMware创建虚拟机，也可买个单机装、双系统、WSL、docker…</li>
</ol>
<h3 id="文件与目录结构🏂"><a href="#文件与目录结构🏂" class="headerlink" title="文件与目录结构🏂"></a>文件与目录结构🏂</h3><h4 id="Linux文件🏄‍♂️"><a href="#Linux文件🏄‍♂️" class="headerlink" title="Linux文件🏄‍♂️"></a>Linux文件🏄‍♂️</h4><p>Linux系统中一切届文件</p>
<h4 id="挂载点🏄‍♂️"><a href="#挂载点🏄‍♂️" class="headerlink" title="挂载点🏄‍♂️"></a><strong>挂载点🏄‍♂️</strong></h4><p>假设你有一个 USB 存储设备（如闪存驱动器或移动硬盘），你想要在 Linux 中访问该设备上的文件。首先，你需要找到一个目录，作为该设备的挂载点。你可以选择一个现有的目录，如 <code>/mnt</code> 或 <code>/media</code>，或者创建一个新的目录，如 <code>/mnt/usb</code>。</p>
<p>然后，通过执行挂载命令，将该 USB 设备与挂载点关联起来。例如，使用以下命令将 <code>/dev/sdb1</code>（USB 设备的第一个分区）挂载到 <code>/mnt/usb</code> 目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount /dev/sdb1 /mnt/usb</span><br></pre></td></tr></table></figure>

<p>执行此命令后，USB 设备上的文件和文件夹就可以通过 <code>/mnt/usb</code> 目录进行访问了。你可以在终端中浏览该目录，查看和操作 USB 设备上的文件。</p>
<p>当你完成使用 USB 设备后，可以使用 <code>umount</code> 命令卸载挂载点，断开设备与文件系统之间的连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">umount /mnt/usb</span><br></pre></td></tr></table></figure>

<p>这样，USB 设备就会从挂载点上卸载，不再与文件系统关联。</p>
<p>总而言之，挂载点是将存储设备或分区与文件系统层次结构中的特定目录连接起来的过程。通过挂载，设备上的文件和文件夹可以在指定的目录下进行访问和操作。</p>
<p><em>Linux的目录也叫作虚拟目录（不管底层到底存在哪，逻辑上有映射关系就行）</em></p>
<h4 id="Linux目录结构🏄‍♂️"><a href="#Linux目录结构🏄‍♂️" class="headerlink" title="Linux目录结构🏄‍♂️"></a>Linux目录结构🏄‍♂️</h4><p><img src="/img/linux/07.jpg"></p>
<p>👉&#x2F;<strong>bin:</strong> Binary的缩写。存放系统命令，普通用户和 root 都可以执行。放在 &#x2F;bin 下的命令在单用户模式下也可以执行。<br>👉&#x2F;<strong>boot:</strong> 这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。<br>👉&#x2F;<strong>dev：</strong> Device的缩写。该目录下存放的是 Linux 的<strong>外部设备</strong>，在 Linux 中访问设备的方式和访问文件的方式是相同的。<br>👉&#x2F;<strong>etc：</strong> Etcetera的缩写。这个目录用来存放所有的系统管理所需要的<strong>配置文件</strong>和子目录。<br>👉&#x2F;<strong>home：</strong> 用户的(<strong>普通用户</strong>，<em>超级用户在&#x2F;root下</em>)主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。<br>👉&#x2F;<strong>lib：</strong> Library的缩写。这个目录里存放着系统最基本的<em><strong>动态连接共享库</strong></em>，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。<br>👉&#x2F;<strong>lib64：</strong> 64位相关的库会放在这。<br>👉&#x2F;<strong>media：</strong> linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备<strong>挂载</strong>到这个目录下。<br>👉&#x2F;<strong>mnt：</strong> 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。<br>👉&#x2F;<strong>opt：</strong> optional的缩写。这是给主机额外安装软件所摆放的目录(第三方软件都可以放到这个目录下)。<br>👉&#x2F;<strong>proc：</strong> Processes的缩写。&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里<br>👉**&#x2F;root：** 该目录为系统管理员，也称作超级权限者的<strong>用户主目录</strong>。<br>👉&#x2F;<strong>run：</strong> 运行目录<br>👉&#x2F;<strong>sbin：</strong> s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。<br>👉&#x2F;<strong>srv：</strong> service的缩写，该目录存放一些服务启动之后需要提取的数据。<br>👉&#x2F;<strong>sys：</strong> system的缩写，虚拟文件系统。和 &#x2F;proc&#x2F; 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息<br>👉&#x2F;<strong>tmp：</strong> temporary的缩写这个目录是用来存放一些临时文件的。<br>👉&#x2F;<strong>usr：</strong> unix system resources缩写。用于存储系统软件资源。<br>👉&#x2F;<strong>var：</strong> 用于存储动态数据，例如<strong>缓存、日志文件、软件运行过程中产生的文件</strong>等</p>
<p>上述目录结构介绍引用自该<a href="https://blog.csdn.net/da_ge_de_nv_ren/article/details/128391575">博客</a></p>
<h3 id="vi-vim编辑器🎫"><a href="#vi-vim编辑器🎫" class="headerlink" title="vi&#x2F;vim编辑器🎫"></a>vi&#x2F;vim编辑器🎫</h3><p><img src="/img/linux/08.gif"></p>
<p><em>vi和vim都是多模式编辑器，区别在于：vim 是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面。vi使用于文本编辑，但是vim更适用于coding。</em> </p>
<p>vim(编辑器之神) emacs(神之编辑器)</p>
<p><img src="/img/linux/09.png"></p>
<h4 id="一般-普通-模式🏌️‍♂️"><a href="#一般-普通-模式🏌️‍♂️" class="headerlink" title="一般(普通)模式🏌️‍♂️"></a>一般(普通)模式🏌️‍♂️</h4><p><strong>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</strong></p>
<p>此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符，比如我们此时按下 <strong>i</strong>，并不会输入一个字符，<strong>i</strong> 被当作了一个命令。</p>
<p>以下是普通模式常用的几个命令：</p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td align="center">切换到输入模式，在光标当前位置开始输入文本</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">剪切当前光标所在处的字符(从左往后)</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">剪切当前光标所在处的字符(从右往左)</td>
</tr>
<tr>
<td align="center">:</td>
<td align="center">切换到底线命令模式，以在最底一行输入命令</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">进入插入模式，在光标下一个位置开始输入文本</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">在当前行的下方插入一个新行，并进入插入模式</td>
</tr>
<tr>
<td align="center">w</td>
<td align="center">跳转到当前光标指向单词的下一个单词</td>
</tr>
<tr>
<td align="center">r</td>
<td align="center">替换当前光标所在的字符   （<em>如r+1 把r替换成1</em>)</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">进入替换模式(可看作特殊的插入模式)</td>
</tr>
<tr>
<td align="center">O</td>
<td align="center">在当前行的上方插入一个新行，并进入插入模式</td>
</tr>
<tr>
<td align="center">dd</td>
<td align="center">删除当前行                <em>3 + dd 删除3行</em></td>
</tr>
<tr>
<td align="center">yy</td>
<td align="center">复制当前行                <em>8 + yy 复制8行</em></td>
</tr>
<tr>
<td align="center"><em>y$</em></td>
<td align="center">复制光标之后的所有内容</td>
</tr>
<tr>
<td align="center"><em>y^</em></td>
<td align="center">复制光标之前的所有内容</td>
</tr>
<tr>
<td align="center"><em>y+w</em></td>
<td align="center">复制当前光标所在的单词(w是word)</td>
</tr>
<tr>
<td align="center"><em>d+w</em></td>
<td align="center">删除当前光标所在的单词(w是word)</td>
</tr>
<tr>
<td align="center">p (小写)</td>
<td align="center">粘贴剪贴板内容到光标下方    <em>5+p复制5行</em></td>
</tr>
<tr>
<td align="center">P (大写)</td>
<td align="center">粘贴剪贴板内容到光标上方</td>
</tr>
<tr>
<td align="center">u</td>
<td align="center">撤销上一次操作</td>
</tr>
<tr>
<td align="center">Ctrl + r</td>
<td align="center">重做上一次撤销的操作</td>
</tr>
<tr>
<td align="center">:w</td>
<td align="center">保存文件</td>
</tr>
<tr>
<td align="center">:q</td>
<td align="center">退出 Vim 编辑器</td>
</tr>
<tr>
<td align="center">:q!</td>
<td align="center">强制退出 Vim 编辑器，不保存修改</td>
</tr>
<tr>
<td align="center">shit + ^</td>
<td align="center">移动到行首</td>
</tr>
<tr>
<td align="center">shift + $</td>
<td align="center">移动到行尾</td>
</tr>
<tr>
<td align="center">gg</td>
<td align="center">移动到第一行的行首</td>
</tr>
<tr>
<td align="center">GG</td>
<td align="center">移动到最后一行的行首</td>
</tr>
<tr>
<td align="center">数字+G</td>
<td align="center">移动到指定行行首</td>
</tr>
</tbody></table>
<p><strong>vim关于永久行号的配置</strong>&#x3D;&gt;<a href="https://blog.csdn.net/weixin_43025343/article/details/123241388?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170426108916800211519045%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170426108916800211519045&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123241388-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=vim%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7&spm=1018.2226.3001.4187">看此博客介绍</a></p>
<h4 id="编辑模式🏌️‍♂️"><a href="#编辑模式🏌️‍♂️" class="headerlink" title="编辑模式🏌️‍♂️"></a>编辑模式🏌️‍♂️</h4><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td align="center">从当前光标处进入插入模式</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">进入插入模式，并置光标于行首</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">追加模式，置光标于当前光标之后</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">追加模式，置光标于行末</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">在当前行之下新加一行，并进入插入模式</td>
</tr>
<tr>
<td align="center">O</td>
<td align="center">在当前行之上新加一行，并进入插入模式</td>
</tr>
<tr>
<td align="center">Esc</td>
<td align="center">退出插入模式</td>
</tr>
</tbody></table>
<h4 id="命令模式🏌️‍♂️"><a href="#命令模式🏌️‍♂️" class="headerlink" title="命令模式🏌️‍♂️"></a>命令模式🏌️‍♂️</h4><p><em><strong>可以看作一般模式下的特殊操作</strong></em></p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:w</td>
<td align="center">保存当前文件</td>
</tr>
<tr>
<td align="center">:w!</td>
<td align="center">强制保存当前文件，即使是只读文件</td>
</tr>
<tr>
<td align="center">:q</td>
<td align="center">退出 Vim 编辑器</td>
</tr>
<tr>
<td align="center">:q!</td>
<td align="center">强制退出 Vim 编辑器，丢弃修改</td>
</tr>
<tr>
<td align="center">:wq</td>
<td align="center">保存并退出 Vim 编辑器</td>
</tr>
<tr>
<td align="center">ZZ</td>
<td align="center">等同于 :wq，保存并退出 Vim 编辑器</td>
</tr>
<tr>
<td align="center">ZQ</td>
<td align="center">等同于 :q!，强制退出 Vim 编辑器</td>
</tr>
<tr>
<td align="center">:w [文件名]</td>
<td align="center">将编辑的数据保存到另一个文件</td>
</tr>
<tr>
<td align="center">:r [文件名]</td>
<td align="center">在当前行后插入指定文件的内容</td>
</tr>
<tr>
<td align="center">:n1,n2 w [文件名]</td>
<td align="center">将 n1 到 n2 行的内容保存到指定文件</td>
</tr>
<tr>
<td align="center">:!命令</td>
<td align="center">在指令行模式下执行命令，并显示结果</td>
</tr>
<tr>
<td align="center">:set nu</td>
<td align="center">显示行号</td>
</tr>
<tr>
<td align="center">:set nonu</td>
<td align="center">取消显示行号</td>
</tr>
<tr>
<td align="center">:noh</td>
<td align="center">取消高亮显示当前搜索的匹配项</td>
</tr>
<tr>
<td align="center">&#x2F; + 你想要搜索的stirng</td>
<td align="center">搜索后会高亮显示，n向下找，N向上找</td>
</tr>
<tr>
<td align="center">:s&#x2F;old&#x2F;new</td>
<td align="center">替换<strong>当前行第一个</strong>匹配到的 old 为 new</td>
</tr>
<tr>
<td align="center">:s&#x2F;old&#x2F;new&#x2F;g</td>
<td align="center">替换<strong>当前行所有</strong>匹配到的 old 为 new</td>
</tr>
<tr>
<td align="center">:%s&#x2F;old&#x2F;new</td>
<td align="center">替换<strong>整个文档</strong>中每一行第一个匹配到的 old 为 new</td>
</tr>
<tr>
<td align="center">:%s&#x2F;old&#x2F;new&#x2F;g</td>
<td align="center">替换整个文档中所有匹配到的 old 为 new</td>
</tr>
</tbody></table>
<h3 id="网络配置🤖"><a href="#网络配置🤖" class="headerlink" title="网络配置🤖"></a>网络配置🤖</h3><p>先了解一下网络吧 <a href="https://hoochanlon.github.io/helpdesk-guide/enhance/net/neta.html#ip%E5%9C%B0%E5%9D%80%E7%9A%84%E8%AE%BE%E8%AE%A1">一篇全文让你彻底理清IP地址、子网掩码、网关</a>、<a href="https://www.bilibili.com/video/BV1xu411f7UW/?spm_id_from=333.337.search-card.all.click&vd_source=4452cbcad134fb17ec9cfb03a0acbdac">子网掩码的介绍</a>、<a href="https://www.bilibili.com/video/BV1aF411v7hU/?spm_id_from=pageDriver&vd_source=4452cbcad134fb17ec9cfb03a0acbdac">IPv6和IPv4的主要区别？子网掩码，二进制转化，地址分类，头部，安全有什么不同？</a>、<a href="https://www.bilibili.com/video/BV1Gz4y1r791/?spm_id_from=333.337.search-card.all.click&vd_source=4452cbcad134fb17ec9cfb03a0acbdac">小白成神之路，网络知识看这一期足矣！软路由 桥接 端口转发 旁路由 单臂路由 IPv4 IPv6 DDNS</a>、<a href="https://www.bilibili.com/video/BV1vp4y1L7Yb/?spm_id_from=333.788.recommend_more_video.0&vd_source=4452cbcad134fb17ec9cfb03a0acbdac">走出这个视频时，你也可以【懂一点电脑】</a></p>
<h5 id="远程登录👩‍🏫"><a href="#远程登录👩‍🏫" class="headerlink" title="远程登录👩‍🏫"></a>远程登录👩‍🏫</h5><p>本地远程登录linux，以ssh为例</p>
<p>ssh root@ip或者hostname</p>
<p>例如 ssh root@jzx，就是用root用户登录主机名为jzx的服务器中。</p>
<p>若遇到permission denied等问题，去查解决方案。</p>
<p>主流的一些工具，如Xshell，Finalshell都是用ssh免密登录的</p>
<h3 id="系统管理📚"><a href="#系统管理📚" class="headerlink" title="系统管理📚"></a>系统管理📚</h3><h4 id="Linux中的进程和服务🤹‍♂️"><a href="#Linux中的进程和服务🤹‍♂️" class="headerlink" title="Linux中的进程和服务🤹‍♂️"></a>Linux中的进程和服务🤹‍♂️</h4><p><strong><em>进程(process)</em>:</strong> 计算机中一个正在执行的程序或命令</p>
<p><strong>服务(service):</strong> 启动之后一直存在、常驻内存的进程</p>
<p><strong>守护进程(daemon):</strong> 执行系统服务的进程</p>
<p><strong>注意</strong>:有些以d结尾的服务，都是守护进程;在linux中，守护进程就是系统服务</p>
<h5 id="远程登录👩‍🏫-1"><a href="#远程登录👩‍🏫-1" class="headerlink" title="远程登录👩‍🏫"></a>远程登录👩‍🏫</h5><p>本地远程登录linux，以ssh为例</p>
<p>ssh root@ip或者hostname</p>
<p>例如 ssh root@jzx，就是用root用户登录主机名为jzx的服务器中。</p>
<p>若遇到permission denied等问题，去查解决方案。</p>
<p>主流的一些工具，如Xshell，Finalshell都是用ssh免密登录的</p>
<h3 id="系统管理📚-1"><a href="#系统管理📚-1" class="headerlink" title="系统管理📚"></a>系统管理📚</h3><h4 id="Linux中的进程和服务🤹‍♂️-1"><a href="#Linux中的进程和服务🤹‍♂️-1" class="headerlink" title="Linux中的进程和服务🤹‍♂️"></a>Linux中的进程和服务🤹‍♂️</h4><p><strong><em>进程(process)</em>:</strong> 计算机中一个正在执行的程序或命令</p>
<p><strong>服务(service):</strong> 启动之后一直存在、常驻内存的进程</p>
<p><strong>守护进程(daemon):</strong> 执行系统服务的进程</p>
<p><strong>注意</strong>:有些以d结尾的服务，都是守护进程;在linux中，守护进程就是系统服务</p>
<h2 id="常用基本命令☝"><a href="#常用基本命令☝" class="headerlink" title="常用基本命令☝"></a>常用基本命令☝</h2><p>shell可以看作一个命令解释器，我们输入给终端控制台的命令，通过shell进行解释并最终交给内核执行。</p>
<p>Bash（全称<strong>Bourne-Again SHell</strong>）是GNU 开发的一个Shell。 Bash 是目前绝大多数Linux 发行版的默认Shell</p>
<h3 id="帮助命令👈"><a href="#帮助命令👈" class="headerlink" title="帮助命令👈"></a>帮助命令👈</h3><p>1.<strong>man</strong> : 获得外部命令帮助信息 ，如man ls</p>
<p>2.<strong>help</strong> : 获得shell内置命令的帮助信息，如help cd</p>
<p><em>help看参数用法更方便，但是只能看内嵌命令的</em></p>
<p>不过有个对于外部命令看起来更方便的，如ls –help。</p>
<p>但是想看最全的还得是man </p>
<p><strong>提示</strong> : 可以用type 命令判断是哪种 </p>
<p><strong>shell中常用快捷键:</strong></p>
<table>
<thead>
<tr>
<th align="center">常用快捷键</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ctrl + c</td>
<td align="center">停止进程</td>
</tr>
<tr>
<td align="center">ctrl + l</td>
<td align="center">清屏，等同于clear；彻底清屏是: reset</td>
</tr>
<tr>
<td align="center">善于用tab键</td>
<td align="center">提示(更重要的是可以防止敲错)</td>
</tr>
<tr>
<td align="center">上下键</td>
<td align="center">查找执行过的命令</td>
</tr>
</tbody></table>
<h3 id="文件目录类👈"><a href="#文件目录类👈" class="headerlink" title="文件目录类👈"></a>文件目录类👈</h3><p><img src="/img/linux/10.gif"></p>
<p><strong>cd &#x2F;</strong>: 在<a href="https://so.csdn.net/so/search?q=Linux&spm=1001.2101.3001.7020">Linux</a> 系统中斜杠“&#x2F;”表示的是<strong>根目录</strong>。cd &#x2F; ,即进入根目录.<br><strong>cd ~<strong>命令是，进入用户在</strong>该系统的home目录</strong>，例如xz用户，则进入&#x2F;root&#x2F;xz目录</p>
<p><strong>cd -</strong> 回到上一个文件夹,可以在两个目录里反复横跳</p>
<p><strong>.&#x2F;</strong> 代表当前目录下的文件或者文件夹； <strong>..&#x2F;</strong> 代表当前目录的上一级目录中的文件或者文件夹。可以发现ls -a的话，.和..也会显示；linux中的隐藏文件or隐藏文件夹都以.开头</p>
<p>单个cd 回到主目录</p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pwd</td>
<td align="center">显示当前工作目录的<strong>绝对路径</strong> ; pwd -P显示实际物理路径</td>
</tr>
<tr>
<td align="center">ls</td>
<td align="center"><strong>ls:列出目录内容</strong>    ls -a(all):全部的文件，连同隐藏档（以.开头）一起列出来   ls -l 长数据串列出，包含文件的属性与权限等等数据；(常用)等价于”ll”  ；也可以并一起写ls -al</td>
</tr>
<tr>
<td align="center">mkdir</td>
<td align="center"><strong>创建文件夹</strong>；<em><strong>mkdir -p</strong></em><em>最常用</em>**,若没父目录，直接也给创建了              如mkdir -p &#x2F;g&#x2F;h&#x2F;i</td>
</tr>
<tr>
<td align="center">rmdir</td>
<td align="center"><strong>删除文件夹</strong>;rmdir -p 删除指定的空目录，及其内的子空目录：</td>
</tr>
<tr>
<td align="center">touch</td>
<td align="center"><strong>创建空文件</strong>:touch + 文件名称   ;<strong>注意</strong>:vim也可以创建一个空文件，不过得保存才行，不然就没有，这是和touch的一个区别</td>
</tr>
<tr>
<td align="center">cp</td>
<td align="center"><strong>复制文件或目录</strong>；cp [选项] source(源文件) dest(目的地);  <strong>cp - r</strong>:(recusive 递归地)：使用-r选项，cp指令会递归地复制目录及其内容，包括子目录和文件。</td>
</tr>
<tr>
<td align="center">rm</td>
<td align="center"><strong>递归删除目录中所有内容</strong>；rm [选项] deleteFile；**-f**:强制执行删除 ； <strong>-r</strong>:递归删除目录中所有内容； <strong>-v</strong>  ;  <strong>rm-rf</strong>很强大,rm -rf &#x2F;* 删库跑路</td>
</tr>
<tr>
<td align="center">mv</td>
<td align="center">mv oldNameFile newNameFile（功能描述:<strong>重命名</strong>）; mv &#x2F;temp&#x2F;movefile&#x2F;targetFolder(功能描述:<strong>移动文件</strong>)</td>
</tr>
<tr>
<td align="center">cat</td>
<td align="center">查看文件内容; cat</td>
</tr>
<tr>
<td align="center">more</td>
<td align="center">more [选项] 要查看的文件。more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以<strong>按页来查看文件的内容，还支持直接跳转行等功能。</strong></td>
</tr>
<tr>
<td align="center">less</td>
<td align="center">less [参数]  文件 ；less 与 more 类似，<strong>但使用 less 可以随意浏览文件，而且 less 在查看之前不会加载整个文件</strong>。显示方面，显示内容方式不是输出到窗口，而是类似vi打开的文件一样，退出按q。</td>
</tr>
<tr>
<td align="center">echo</td>
<td align="center"><strong>输出内容到控制台</strong>‘’;echo [选项] [输出内容] ;   -e：支持反斜线控制的字符转换</td>
</tr>
<tr>
<td align="center">&gt;和&gt;&gt;</td>
<td align="center"><strong>&gt; 输出重定向</strong>** 和 &gt;&gt;<strong>追加</strong> ； 如<strong>ls -l &gt; 文件</strong>(功能描述:列表的内容写入a.txt中(覆盖写)) ；如 <strong>echo “hello linux” &gt;&gt; test.c</strong>：把hello linux追加到test.c后面；</td>
</tr>
<tr>
<td align="center">head</td>
<td align="center">head [OPTIONS] FILES ;(功能描述:<strong>输出文本前面部分</strong>)</td>
</tr>
<tr>
<td align="center">tail</td>
<td align="center">tail [OPTIONS] FILES；(功能描述:<strong>输出文本后面部分</strong>(默认查看文件尾部后10行));  tail -n 5 fileName (查看文件尾部5行) ;  <strong>tail -f fileName</strong>(功能描述:<strong>实时追踪该文档的所有更新</strong>)   注意:如果用vim加的化，得用<strong>tail -F</strong></td>
</tr>
<tr>
<td align="center">ln</td>
<td align="center"><strong>软链接</strong>  ln -s [原文件或目录] [软链接名] (功能描述:给原文件创建一个软链接)  创建后可通过ls -l可以查看详细信息; <strong>删除软链接: rm -rf软链接名,而不是rm -rf 软链接名&#x2F;，如果使用rm -rf 软链接名&#x2F; ,会把软链接对应的真实目录下内容删掉</strong>  ;<strong>重要</strong>： <a href="https://blog.csdn.net/weixin_44895651/article/details/105289038?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170442121416800182782629%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=170442121416800182782629&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-6-105289038-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=linux%E8%BD%AF%E9%93%BE%E6%8E%A5&spm=1018.2226.3001.4187">硬链接和软链接的区别</a>  ;<em><strong>实际应用基本都是软链接</strong></em></td>
</tr>
<tr>
<td align="center">history</td>
<td align="center"><strong>查看历史命令</strong></td>
</tr>
</tbody></table>
<h3 id="时间日期类👈"><a href="#时间日期类👈" class="headerlink" title="时间日期类👈"></a>时间日期类👈</h3><p>基本语法：date [OPTION]…[+FORMAT]</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-d&lt;时间字符串&gt;</td>
<td>显示指定的”时间字符串”表示的时间,而非当前时间</td>
</tr>
<tr>
<td>-s&lt;日期时间&gt;</td>
<td>设置系统日期时间</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>具体用法见:<a href="https://blog.csdn.net/weixin_43901998/article/details/126634560?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170442499616800227422988%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170442499616800227422988&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-126634560-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=linux%20date&spm=1018.2226.3001.4187">date各种用法</a></p>
<p> 还有cal 日历类等等</p>
<h3 id="用户管理类👈"><a href="#用户管理类👈" class="headerlink" title="用户管理类👈"></a>用户管理类👈</h3><h4 id="用户🧍‍♂️"><a href="#用户🧍‍♂️" class="headerlink" title="用户🧍‍♂️"></a>用户🧍‍♂️</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">useradd</td>
<td align="center">useradd 用户名:<strong>添加新用户</strong>; useradd + g 组名 用户名：<strong>添加新用户到某个组</strong></td>
</tr>
<tr>
<td align="center">cat &#x2F;ect&#x2F;passwd</td>
<td align="center"><strong>查看创建了哪些用户</strong>，文档中很多没见过的用户都是系统单独创建出来运行系统服务的，不需要改。<img src="/img/linux/11.png">以contigo为例 第一个1001是uid，第二个1001是gid，&#x2F;home&#x2F;contigo是家目录,&#x2F;bin&#x2F;sh指此用户与系统交互的进程</td>
</tr>
<tr>
<td align="center">su</td>
<td align="center"><strong>切换用户</strong>（switch user）；su 用户名称(切换用户，只能获得用户的执行权限，不能获得环境变量) su - 用户名称(切换到用户并获得该用户的环境变量及执行权限)</td>
</tr>
<tr>
<td align="center">who am i&#x2F;whoami</td>
<td align="center">前者是显示<strong>最原始的进来时的用户</strong>，后者是<strong>当前用户</strong></td>
</tr>
<tr>
<td align="center">sudo</td>
<td align="center"><strong>设置用户具有root权限</strong> ; 修改配置文件 vim &#x2F;ect&#x2F;sudoers 在root下添加需要添加的用户和对应的权限</td>
</tr>
<tr>
<td align="center">userdel</td>
<td align="center"><strong>删除用户</strong> ，但是不会删除文件夹，<strong>只是删除用户</strong> ；  userdel -r david 会把用户<strong>连同目录文件</strong>一起删</td>
</tr>
<tr>
<td align="center">id</td>
<td align="center">id + 用户名称： <strong>查看用户信息</strong></td>
</tr>
</tbody></table>
<h4 id="用户组🧍‍♂️"><a href="#用户组🧍‍♂️" class="headerlink" title="用户组🧍‍♂️"></a>用户组🧍‍♂️</h4><p>linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建</p>
<p>所有用户组的信息都在 <strong>&#x2F;ect&#x2F;group</strong></p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">快捷键</th>
</tr>
</thead>
<tbody><tr>
<td align="center">groupadd</td>
<td align="center">groupadd + 组名 <strong>新增用户组</strong></td>
</tr>
<tr>
<td align="center">usermod -g</td>
<td align="center">usermod -g 用户组 用户名 <strong>修改用户</strong></td>
</tr>
<tr>
<td align="center">groupmod - n</td>
<td align="center">groupmod -n newName oldName : <strong>给用户组改名</strong></td>
</tr>
<tr>
<td align="center">groupdel</td>
<td align="center">groupdel + 组名 : <strong>删除用户组</strong></td>
</tr>
</tbody></table>
<h3 id="文件权限类👈"><a href="#文件权限类👈" class="headerlink" title="文件权限类👈"></a>文件权限类👈</h3><h4 id="文件属性和权限📒"><a href="#文件属性和权限📒" class="headerlink" title="文件属性和权限📒"></a>文件属性和权限📒</h4><p>有了很多用户组，想要区别他们，就得给不同的用户组不同的操作权限。</p>
<p>在linux中ll &#x2F; ls -l 可以显示一个文件的属性及其文件所属的用户和组</p>
<p><img src="/img/linux/12.png"></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/363003_1227493859FdXT.png" alt="363003_1227493859FdXT"></p>
<p>当为 <strong>d</strong> 则是目录</p>
<p>当为 <strong>-</strong> 则是文件；</p>
<p>若是 <strong>l</strong> 则表示为链接文档(link file)；</p>
<p>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</p>
<p>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</p>
<p>从左至右用 <strong>0-9</strong> 这些数字来表示。</p>
<p>第 <strong>0</strong> 位确定文件类型，第 <strong>1-3</strong> 位确定属主（该文件的所有者 即user）拥有该文件的权限。</p>
<p>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<p>其中，第 <strong>1、4、7</strong> 位表示读权限，如果用 <strong>r</strong> 字符表示，则有读权限，如果用 <strong>-</strong> 字符表示，则没有读权限；</p>
<p>第 <strong>2、5、8</strong> 位表示写权限，如果用 <strong>w</strong> 字符表示，则有写权限，如果用 <strong>-</strong> 字符表示没有写权限；第 <strong>3、6、9</strong> 位表示可执行权限，如果用 <strong>x</strong> 字符表示，则有执行权限，如果用 <strong>-</strong> 字符表示，则没有执行权限。</p>
<p><em><strong>注意</strong></em>:删除文件一个文件需要的不是对该文件是否有写权限，而是对<strong>该文件所在的目录</strong>有写权限）</p>
<h4 id="更改文件权限📒"><a href="#更改文件权限📒" class="headerlink" title="更改文件权限📒"></a>更改文件权限📒</h4><p><img src="/img/linux/13.png" alt="img"></p>
<h5 id="chmod-改变权限-📃"><a href="#chmod-改变权限-📃" class="headerlink" title="chmod 改变权限:📃"></a><strong>chmod 改变权限</strong>:📃</h5><p><strong>第一种方式</strong>变更权限 </p>
<p>chmod [{ugoa} {+-&#x3D;} {rwx}] 文件或目录</p>
<p>例 chmod u+x fileName，让属主添加能执行该文件的权限</p>
<p>​	chmod a&#x3D;rw fileName 让文件的ugo权限都可读可写</p>
<p><strong>第二种方式</strong>变更权限（<strong>更直接 更简单</strong>)</p>
<p>chmod [mode&#x3D;421] [文件或目录]</p>
<p><strong>技巧</strong> </p>
<p>u:所有者 g：所有组 o:其他人 a:所有人(u、g、o的总和)</p>
<p><strong>r&#x3D;4 w&#x3D;2 x&#x3D;1 rwx&#x3D;4+2+1&#x3D;7</strong> (用图中的二进制去理解)，如 <strong>chmod 777 file</strong></p>
<p>菜鸟教程有<a href="https://www.runoob.com/linux/linux-comm-chmod.html">更细的</a></p>
<p>修改整个文件夹里面的所有文件的所有者、所属组、其他用户都具有可度可写可执行权限。</p>
<p><strong>chmod -R 777 xiyou&#x2F;</strong></p>
<h5 id="chown-改变所有者📃"><a href="#chown-改变所有者📃" class="headerlink" title="chown 改变所有者📃"></a>chown 改变所有者📃</h5><p><strong>chown [选项] [最终用户] [文件或目录]</strong> (功能描述: <strong>改变文件或者目录的所有者</strong>)</p>
<p>chown -R:递归操作</p>
<h5 id="chgrp-改变所有组📃"><a href="#chgrp-改变所有组📃" class="headerlink" title="chgrp 改变所有组📃"></a>chgrp 改变所有组📃</h5><h3 id="搜索查找类👈"><a href="#搜索查找类👈" class="headerlink" title="搜索查找类👈"></a>搜索查找类👈</h3><h4 id="find📓"><a href="#find📓" class="headerlink" title="find📓"></a>find📓</h4><p><strong>find [搜索范围] [选项]</strong></p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-name&lt;查找方式&gt;</td>
<td align="center">按照指定的文件名查找模式查找文件</td>
</tr>
<tr>
<td align="center">-user&lt;用户名&gt;</td>
<td align="center">查找属于指定用户名所有文件</td>
</tr>
<tr>
<td align="center">-size&lt;文件大小&gt;</td>
<td align="center">按照指定的文件大小查找文件,单位为:b 一 块 c 一 字节，w 一 字（2字节）,k 一 千字节,M 一 兆字节 ， G 一 吉字节</td>
</tr>
</tbody></table>
<h4 id="locate📓"><a href="#locate📓" class="headerlink" title="locate📓"></a>locate📓</h4><h4 id="grep📓"><a href="#grep📓" class="headerlink" title="grep📓"></a>grep📓</h4><p><strong>管道符,“ | ”</strong>,表示将前一个命令的处理结果输出传递给后面的命令处理</p>
<p><strong>grep 选项 查找内容 源文件</strong>(在源文件中查找内容)</p>
<p>-n 显示匹配</p>
<p>与管道符经常一起用,如ls | grep .c ，查找后缀为.c的文件</p>
<p>补充 : <strong>wc</strong>命令</p>
<p> <strong>显示 行数,单词数量，字节数， 文件名</strong></p>
<h3 id="压缩解压类👈"><a href="#压缩解压类👈" class="headerlink" title="压缩解压类👈"></a>压缩解压类👈</h3><h4 id="gzip-gunzip-压缩📔"><a href="#gzip-gunzip-压缩📔" class="headerlink" title="gzip&#x2F;gunzip 压缩📔"></a>gzip&#x2F;gunzip 压缩📔</h4><p><strong>gzip 文件</strong> (压缩文件，只能将文件压缩为*.gz文件)</p>
<p><strong>gunzip 文件.gz</strong>（解压缩文件命令）</p>
<p><strong>技巧</strong></p>
<p>(1)只能压缩文件不能压缩目录</p>
<p>(2)不保留原来的文件</p>
<p>(3)同时多个文件会产生多个压缩包</p>
<h4 id="zip-unzip压缩📔"><a href="#zip-unzip压缩📔" class="headerlink" title="zip&#x2F;unzip压缩📔"></a>zip&#x2F;unzip压缩📔</h4><p> <strong>zip 选项 -r 压缩目录</strong></p>
<p><strong>unzip 选项 -d 指定解压后文件的存放目录</strong></p>
<h4 id="tar打包📔"><a href="#tar打包📔" class="headerlink" title="tar打包📔"></a>tar打包📔</h4><p><strong>tar [选项] XXX.tar.gz 将要打包进去的内容</strong> (打包目录，压缩后的文件格式.tar.gz)</p>
<p>tar -zcvf 打包</p>
<p>tar -zxvf解包</p>
<p><strong>选项</strong></p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-c</td>
<td>产生.tar打包文件</td>
</tr>
<tr>
<td align="center">-v</td>
<td>显示详细信息</td>
</tr>
<tr>
<td align="center">-f</td>
<td>指定压缩后的文件名</td>
</tr>
<tr>
<td align="center">-z</td>
<td>打包同时压缩</td>
</tr>
<tr>
<td align="center">-x</td>
<td>解包.tar文件</td>
</tr>
<tr>
<td align="center">-C</td>
<td>解压到指定目录</td>
</tr>
</tbody></table>
<h3 id="磁盘分区类👈"><a href="#磁盘分区类👈" class="headerlink" title="磁盘分区类👈"></a>磁盘分区类👈</h3><h4 id="du-查看文件和目录占用的磁盘空间🎇"><a href="#du-查看文件和目录占用的磁盘空间🎇" class="headerlink" title="du 查看文件和目录占用的磁盘空间🎇"></a>du 查看文件和目录占用的磁盘空间🎇</h4><p>du:即disk usage 磁盘占用情况</p>
<p><strong>du 目录&#x2F;文件</strong> (显示目录下每个子目录的磁盘使用情况)</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-h</td>
<td align="center">以人们较易阅读的GBytes,MBytes,KBytes等格式自行显示；</td>
</tr>
<tr>
<td align="center">-a</td>
<td align="center">不仅查看子目录大小，还要包括文件</td>
</tr>
<tr>
<td align="center">-c</td>
<td align="center">显示所有的文件和子目录大小后，显示总和</td>
</tr>
<tr>
<td align="center">-s</td>
<td align="center">只显示总和</td>
</tr>
<tr>
<td align="center">–max-depth&#x3D;n</td>
<td align="center">指定统计子目录的深度为第n层</td>
</tr>
</tbody></table>
<h4 id="df-查看磁盘空间使用情况🎇"><a href="#df-查看磁盘空间使用情况🎇" class="headerlink" title="df 查看磁盘空间使用情况🎇"></a>df 查看磁盘空间使用情况🎇</h4><p>df：disk free 空余磁盘</p>
<p><strong>df 选项</strong> (列出文件系统的整体磁盘使用量，检查文件系统的磁盘占用情况)</p>
<p>df -h 以人们较易阅读的GBytes,MBytes,KbYTES等格式自行显示</p>
<p><em>了解一些特殊的文件目录可以去查一些资料</em></p>
<h4 id="lsblk-查看设备挂载情况🎇"><a href="#lsblk-查看设备挂载情况🎇" class="headerlink" title="lsblk 查看设备挂载情况🎇"></a>lsblk 查看设备挂载情况🎇</h4><h3 id="进程管理类👈"><a href="#进程管理类👈" class="headerlink" title="进程管理类👈"></a>进程管理类👈</h3><h4 id="ps-查看当前系统进程状态🕹"><a href="#ps-查看当前系统进程状态🕹" class="headerlink" title="ps 查看当前系统进程状态🕹"></a>ps 查看当前系统进程状态🕹</h4><p>ps:process status 进程状态 </p>
<p><strong>ps aux | grep xxx</strong> (<strong>查看系统中所有进程</strong>)  （官方文档不推荐这种写法）</p>
<p><strong>ps -ef | grep xxx</strong> (<strong>可以查看子父进程之间的关系</strong>)</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>列出带有终端的所有用户的进程</td>
</tr>
<tr>
<td>x</td>
<td>列出当前用户的所有进程，包括没有终端的进程</td>
</tr>
<tr>
<td>u</td>
<td>面向用户友好的显示风格</td>
</tr>
<tr>
<td>-e</td>
<td>列出所有进程</td>
</tr>
<tr>
<td>-u</td>
<td>列出某个用户关联的所有进程</td>
</tr>
<tr>
<td>-f</td>
<td>显示完整格式的进程列表</td>
</tr>
</tbody></table>
<h3 id="软件包管理👈"><a href="#软件包管理👈" class="headerlink" title="软件包管理👈"></a>软件包管理👈</h3><h4 id="RPM🧥"><a href="#RPM🧥" class="headerlink" title="RPM🧥"></a>RPM🧥</h4><p>概述</p>
<p>rpm（英文全拼：redhat package manager） 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。</p>
<p>RPM查询命令</p>
<h3 id="克隆虚拟机👈"><a href="#克隆虚拟机👈" class="headerlink" title="克隆虚拟机👈"></a>克隆虚拟机👈</h3><p><a href="https://blog.csdn.net/awd15771131554/article/details/123778655?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170461476216800188535311%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170461476216800188535311&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123778655-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%8B%E9%9A%86&spm=1018.2226.3001.4187">链接</a></p>
<h3 id="Shell编程🥽"><a href="#Shell编程🥽" class="headerlink" title="Shell编程🥽"></a>Shell编程🥽</h3><p>见菜鸟教程<a href="https://www.runoob.com/linux/linux-shell.html">https://www.runoob.com/linux/linux-shell.html</a></p>
<h4 id="概述🖋"><a href="#概述🖋" class="headerlink" title="概述🖋"></a>概述🖋</h4><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p>
<p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p>
<h4 id="变量🖋"><a href="#变量🖋" class="headerlink" title="变量🖋"></a>变量🖋</h4><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p><img src="/../img/linux/13.webp"></p>
]]></content>
      <categories>
        <category>自用</category>
      </categories>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>自用算法笔记(持续更新)</title>
    <url>/2023/12/26/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a>算法笔记</h1><h2 id="1-第一章-基础算法"><a href="#1-第一章-基础算法" class="headerlink" title="1.第一章 基础算法"></a>1.第一章 基础算法</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>重视思想 </p>
<p>好的方法 课下 模板(重复3-5次)思想理解会背 然后做题目 </p>
<h3 id="根据数据量猜解法"><a href="#根据数据量猜解法" class="headerlink" title="根据数据量猜解法"></a>根据数据量猜解法</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E9%87%8F%E7%8C%9C%E8%A7%A3%E6%B3%95.png"></p>
<p>常数指令 一次a+b ,i ++这种就是，假如给你一个1e6长度的数组，用n^2的算法的话，数据量就成了1e12,我们设计的算法肯定不能超过1e7~1e8,假如用n*log2 n ，算下来也就是1e7多一点，未必能超，也许能行。假如是1e3长度，那么n2也行。</p>
<p>注意：上面使用技巧的必要条件↑</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%8C%9C%E8%A7%A3%E6%B3%95%E6%8A%80%E5%B7%A7.png"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="数对问题"><a href="#数对问题" class="headerlink" title="数对问题"></a>数对问题</h4><p><a href="https://leetcode.cn/problems/number-of-good-pairs/">https://leetcode.cn/problems/number-of-good-pairs/</a>  统计好数对</p>
<p><a href="https://leetcode.cn/problems/count-number-of-bad-pairs/description/">https://leetcode.cn/problems/count-number-of-bad-pairs/description/</a> 统计坏数对 双周赛80+</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F1.png"></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F2.png"></p>
<p>用这个就行，防止边界问题</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>思想也是分治,但是方法不一样</p>
<p>先划分区间，再合并</p>
<p>最后那个for是把temp拷贝回去 temp是记录递归排序的数组，每一步都在改变，不能最后直接输出temp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> t[<span class="number">100010</span>];</span><br><span class="line"><span class="comment">/*void merge_sort(int a[],int l,int r)&#123;</span></span><br><span class="line"><span class="comment">    if(l == r)return;</span></span><br><span class="line"><span class="comment">    int mid = l + r &gt;&gt; 1;</span></span><br><span class="line"><span class="comment">    merge_sort(a,l,mid),merge_sort(a,mid+1,r);</span></span><br><span class="line"><span class="comment">    for(int i = l,j = l, k = mid + 1; i &lt;= r; i ++)&#123;</span></span><br><span class="line"><span class="comment">        if(j == mid + 1) </span></span><br><span class="line"><span class="comment">            t[i] = a[k ++];</span></span><br><span class="line"><span class="comment">        else if(k == r + 1)</span></span><br><span class="line"><span class="comment">            t[i] = a[j ++];</span></span><br><span class="line"><span class="comment">        else t[i] = a[j] &lt; a[k] ? a[j ++] : a[k ++];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    for(int i = l; i &lt;= r; i ++)a[i]=t[i];</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//只剩一个元素的时候，已经有序，返回</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找数组中点下标</span></span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//递归给左半边排序</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(a,l,mid);</span><br><span class="line">    <span class="comment">//递归给右半边排序</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(a,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//以下是合并排序好的两个数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//k：遍历合并后的数组的下标</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//i:左半边数组的下标，j:右半边数组的下标</span></span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//左右半边都没遍历完</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="comment">//左边的元素小于右边的元素</span></span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; a[j]) </span><br><span class="line">            <span class="comment">//左边元素放如临时数组，并移动下标</span></span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        <span class="comment">//否则，右边元素放入临时数组并移动下标 </span></span><br><span class="line">        <span class="keyword">else</span> temp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左边数组有剩余，则放入临时数组</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) temp[k++] = a[i++];</span><br><span class="line">    <span class="comment">//如果有边数组有剩余，则放入临时数组</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) temp[k++] = a[j++];</span><br><span class="line">    <span class="comment">//把临时数组中的元素拷贝至原数组</span></span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">        a[i] = temp[k++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge_sort</span>(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例题-逆序对"><a href="#例题-逆序对" class="headerlink" title="例题 逆序对"></a>例题 逆序对</h4><p><a href="https://www.acwing.com/solution/content/5103/%E8%AE%B2%E8%A7%A3%E5%BE%88%E5%A5%BD">https://www.acwing.com/solution/content/5103/讲解很好</a></p>
<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%88%86%E6%B2%BB.png"></p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>例题洛谷P7020，适用情况，要排序的数字值域小，但是n很大的情况，sort和快排这些适合值域大小都可以，n小点的情况</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A1%B6%E6%8E%92%E5%BA%8F.png"></p>
<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p><a href="https://www.luogu.com.cn/problem/P6174">https://www.luogu.com.cn/problem/P6174</a> </p>
<p><a href="https://www.luogu.com.cn/problem/P5815">https://www.luogu.com.cn/problem/P5815</a> 扑克牌[绿题] 二分答案</p>
<p><a href="https://www.luogu.com.cn/problem/P1843">https://www.luogu.com.cn/problem/P1843</a> 二分答案</p>
<p><a href="https://www.acwing.com/solution/content/3338/">https://www.acwing.com/solution/content/3338/</a> 数的范围讲解很好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SL</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (q[mid] &gt;= x) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SR</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(q[mid] &lt;= x) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    <span class="keyword">while</span> ( m-- ) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">SL</span>(<span class="number">0</span>, n - <span class="number">1</span>, x);<span class="comment">//查找左边界 并返回下标l</span></span><br><span class="line">        <span class="keyword">if</span> (q[l]!=x) cout &lt;&lt;<span class="string">&quot;-1 -1&quot;</span>&lt;&lt;endl;<span class="comment">//如果找不到  返回-1 -1</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">//如果找到了  输出左下标</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">SR</span>(<span class="number">0</span>, n - <span class="number">1</span>, x) &lt;&lt; endl; <span class="comment">//输出右下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">浮点数二分算法模板 —— 模板题 AcWing <span class="number">790.</span> 数的三次方根</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有经验，就是假如题目要求4位的话，最好-6，就是比要求的多两位，保证没问题</strong></p>
<h4 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h4><h4 id="lower-bound-和upper-bound"><a href="#lower-bound-和upper-bound" class="headerlink" title="lower_bound( )和upper_bound( )"></a>lower_bound( )和upper_bound( )</h4><p><a href="https://blog.csdn.net/qq_40160605/article/details/80150252">https://blog.csdn.net/qq_40160605/article/details/80150252</a></p>
<p>例题 <a href="https://www.acwing.com/problem/content/732/">https://www.acwing.com/problem/content/732/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以用temp观察发现如果累加的和一直变大，不提前return,会导致负溢出</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> maxH = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> h[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">success</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        temp += temp - h[i];</span><br><span class="line">        <span class="comment">// cout &lt;&lt;&quot;temp ==&quot;&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= maxH) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">        maxH = <span class="built_in">max</span>(maxH, h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = maxH;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">success</span>(mid))</span><br><span class="line">        &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例题 刺杀大使<a href="https://www.luogu.com.cn/problem/P1902">https://www.luogu.com.cn/problem/P1902</a></p>
<p>例题 路标设置 <a href="https://www.luogu.com.cn/problem/P3853">https://www.luogu.com.cn/problem/P3853</a>  和跳石头基本一样（二分求最优解）</p>
<h3 id="高精度（略过）"><a href="#高精度（略过）" class="headerlink" title="高精度（略过）"></a>高精度（略过）</h3><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>模板题</p>
<p><a href="https://www.acwing.com/activity/content/problem/content/1763/">https://www.acwing.com/activity/content/problem/content/1763/</a></p>
<p><a href="https://www.acwing.com/activity/content/problem/content/1764/">https://www.acwing.com/activity/content/problem/content/1764/</a></p>
<p>(很常见的板子题，取中位数)</p>
<p><a href="https://www.matiji.net/exam/brushquestion/3/4347/179CE77A7B772D15A8C00DD8198AAC74">https://www.matiji.net/exam/brushquestion/3/4347/179CE77A7B772D15A8C00DD8198AAC74</a></p>
<p>(用二分答案找时间，check部分贪心一下)</p>
<p><a href="https://www.acwing.com/activity/content/problem/content/1766/">https://www.acwing.com/activity/content/problem/content/1766/</a><br>(y总思路很好)</p>
<p><a href="https://www.acwing.com/activity/content/problem/content/1768/">https://www.acwing.com/activity/content/problem/content/1768/</a></p>
<p><a href="https://www.acwing.com/problem/content/1226/">https://www.acwing.com/problem/content/1226/</a></p>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/994805403651522560?type=7&page=0">https://pintia.cn/problem-sets/994805342720868352/exam/problems/994805403651522560?type=7&amp;page=0</a></p>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/994805350316752896?type=7&page=1">https://pintia.cn/problem-sets/994805342720868352/exam/problems/994805350316752896?type=7&amp;page=1</a></p>
<p><a href="https://www.acwing.com/problem/content/127/">https://www.acwing.com/problem/content/127/</a> 耍杂技的牛（证明搞懂了！）</p>
<p><a href="https://www.acwing.com/activity/content/problem/content/1111/">https://www.acwing.com/activity/content/problem/content/1111/</a> 区间选点(模板,搞懂和区间合并的区别)</p>
<p><a href="https://www.acwing.com/activity/content/problem/content/1112/">https://www.acwing.com/activity/content/problem/content/1112/</a> 和上面区间选点一样</p>
<p><a href="https://www.acwing.com/solution/content/5749/">https://www.acwing.com/solution/content/5749/</a> 这个文章讲得不错</p>
<p><a href="https://www.acwing.com/activity/content/problem/content/1113/">https://www.acwing.com/activity/content/problem/content/1113/</a> 区间分组 （类比活动安排)</p>
<p><a href="https://www.acwing.com/solution/content/8902/%E4%B8%8A%E9%A2%98%E9%A2%98%E8%A7%A3%EF%BC%8C%E9%9D%9E%E5%B8%B8%E5%A6%99">https://www.acwing.com/solution/content/8902/上题题解，非常妙</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> b[<span class="number">2</span> * N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        b[idx ++] = l * <span class="number">2</span>;<span class="comment">//标记左端点为偶数。  就算右端点+1，原来左端点比右端点扩大后依然大</span></span><br><span class="line">        b[idx ++] = r * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">// 标记右端点为奇数。  </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(b, b + idx);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b[i] % <span class="number">2</span> == <span class="number">0</span>) t ++;</span><br><span class="line">    <span class="keyword">else</span> t --;</span><br><span class="line">    res = <span class="built_in">max</span>(res, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>纸牌均分</p>
<p><a href="https://www.luogu.com.cn/problem/P1106">https://www.luogu.com.cn/problem/P1106</a> 删数问题  <strong>找到高峰就删</strong></p>
<h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><p>例题 <a href="https://www.acwing.com/problem/content/description/4963/">https://www.acwing.com/problem/content/description/4963/</a> 子串简写</p>
<p>一维前缀和 —— 模板题 AcWing 795. 前缀和<br><code>S[i] = a[1] + a[2] + ... a[i]</code><br><code>a[l] + ... + a[r] = S[r] - S[l - 1]</code></p>
<p>二维前缀和 —— 模板题 AcWing 796. 子矩阵的和</p>
<p><img src="C:\Users\honor\AppData\Roaming\Typora\typora-user-images\image-20230821143401897.png" alt="image-20230821143401897">S[i, j] &#x3D; 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</p>
<p>例题 K倍区间 <a href="https://www.acwing.com/problem/content/description/1232/">https://www.acwing.com/problem/content/description/1232/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关键是求序列个数的小技巧和搞懂cnt[0]是一个数本身取余K等于0时也可作为一个答案</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">LL A[N];</span><br><span class="line">LL s[N],cnt[N];<span class="comment">//cnt计算相同余数的序列的个数总和 </span></span><br><span class="line">LL res;<span class="comment">//计算不相等的余数的个数总和 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为什么赋值为1？</span></span><br><span class="line"><span class="comment">//因为我们的思路是找两个序列和a%k和b%k的余数相同的个数</span></span><br><span class="line"><span class="comment">//而我们的前缀和一般是不包含S0这个东西的，因为没有意义，但是这道题有意义</span></span><br><span class="line"><span class="comment">//样例里面前缀和序列%k之后是1 1 0 0 1，两两比较，我们只能找到四个</span></span><br><span class="line"><span class="comment">//为什么少了两个？因为我们不一定需要两个序列，单个序列取余=0也构成K倍区间</span></span><br><span class="line"><span class="comment">//也就是说s3 s4这两个区间是能单独成K倍区间的，而我们的思路是找两个序列比较</span></span><br><span class="line"><span class="comment">//此时，我们就要假设S0=0是有意义的，我们就可以有(s0，s3),(s0,s4)这两个组合</span></span><br><span class="line">    cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;A[i]);</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + A[i];</span><br><span class="line">        s[i] = s[i] % k; </span><br><span class="line">        res += (cnt[s[i]]);</span><br><span class="line">        cnt[s[i]] ++;<span class="comment">//记录序列%k不同余数的个数 </span></span><br><span class="line">        <span class="comment">//cnt[s[i]]要在res之后做，因为它是记录总数，如果下面再加回去会重复。 </span></span><br><span class="line">        <span class="comment">/*不能写成</span></span><br><span class="line"><span class="comment">        cnt[s[i]]++;</span></span><br><span class="line"><span class="comment">        res+=(cnt[s[i]]);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//用笔写字调试一下就知道了 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cnt[0] = 1; </span></span><br><span class="line">    <span class="comment">/*for(int i = 1; i &lt;= n; i ++)&#123;</span></span><br><span class="line"><span class="comment">        /*for(int j = i; j &lt;= n; j ++)&#123;</span></span><br><span class="line"><span class="comment">            if(s[j] == 0 &amp;&amp; j &gt; 0) break;</span></span><br><span class="line"><span class="comment">            if((s[j] - s[i - 1]) % k == 0)&#123;</span></span><br><span class="line"><span class="comment">                res ++;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        改成一重循环可以从这里删去。</span></span><br><span class="line"><span class="comment">        这段代码的含义是： 当j固定时，在1-R之间，</span></span><br><span class="line"><span class="comment">                        找到有多少个L，满足([S[右端点] - S[左端点])%k == 0</span></span><br><span class="line"><span class="comment">        从含义上优化代码</span></span><br><span class="line"><span class="comment">        空间换时间 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//res += (cnt[s[i]]);</span></span><br><span class="line">    <span class="comment">/*我刚开始迷惑为什么不是当cnt[s[i]]&gt;=2的时候才加， </span></span><br><span class="line"><span class="comment">      现在懂了，因为不一定是两个区间的重叠序列构成K倍区间，</span></span><br><span class="line"><span class="comment">      一个序列本身如果连续和%k=0也构成K倍区间。故所有的都要加上</span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*10^10&gt;10^8 TLE -&gt; 要改为一重循环*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：Safe_Sound</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/22093/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>例题 <a href="https://www.luogu.com.cn/problem/P3406">https://www.luogu.com.cn/problem/P3406</a></p>
<h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><p>一维差分 —— 模板题 AcWing 797. 差分</p>
<p>二维差分 —— 模板题 AcWing 798. 差分矩阵</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N],b[N][N];</span><br><span class="line"><span class="type">int</span> n, m ,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 +<span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 +<span class="number">1</span>][y2+<span class="number">1</span>] +=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span>( q-- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, x2, y1, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1&gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(x1,y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求前缀和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;= m; j++)</span><br><span class="line">        b[i][j] += b[i<span class="number">-1</span>][j] +b[i][j<span class="number">-1</span>] -b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;= m; j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="位运算-待更"><a href="#位运算-待更" class="headerlink" title="位运算(待更)"></a>位运算(待更)</h3><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%A6%BB%E6%95%A3%E5%8C%96.png"></p>
<p>如果数据范围小的话（10的五次方以内）用前缀和也可</p>
<p>C++用vector作离散化</p>
<p>下面是去重函数的用法</p>
<p><a href="https://blog.csdn.net/tjcwt2011/article/details/125281748?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169275072116800184115652%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169275072116800184115652&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-125281748-null-null.142%5Ev93%5EchatgptT3_1&utm_term=C++%E5%8E%BB%E9%87%8D%E5%87%BD%E6%95%B0&spm=1018.2226.3001.4187">https://blog.csdn.net/tjcwt2011/article/details/125281748?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169275072116800184115652%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169275072116800184115652&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-125281748-null-null.142^v93^chatgptT3_1&amp;utm_term=C%2B%2B%E5%8E%BB%E9%87%8D%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187</a></p>
<p>去重完用sort排序最后用二分查找（好像是先排序后去重</p>
<p>二分函数lower_bound（大于等于） upper_bound（大于）</p>
<p><a href="https://blog.csdn.net/weixin_51566349/article/details/128086465?ops_request_misc=&request_id=&biz_id=102&utm_term=lower_bound&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-128086465.nonecase&spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_51566349/article/details/128086465?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=lower_bound&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-128086465.nonecase&amp;spm=1018.2226.3001.4187</a></p>
<p><a href="https://www.acwing.com/solution/content/80100/%E8%BF%99%E4%B8%AA%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E9%9D%9E%E5%B8%B8%E8%AF%A6%E7%BB%86">https://www.acwing.com/solution/content/80100/这个代码解释非常详细</a></p>
<p>csdn的这个博客也很不错(11.11)</p>
<p><a href="https://blog.csdn.net/qq_54773252/article/details/123286277?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169968370116800182120590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=169968370116800182120590&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~hot_rank-2-123286277-null-null.nonecase&utm_term=%E7%A6%BB%E6%95%A3%E5%8C%96&spm=1018.2226.3001.4450">https://blog.csdn.net/qq_54773252/article/details/123286277?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169968370116800182120590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=169968370116800182120590&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~hot_rank-2-123286277-null-null.nonecase&amp;utm_term=%E7%A6%BB%E6%95%A3%E5%8C%96&amp;spm=1018.2226.3001.4450</a></p>
<h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><p>好多端点问题都是贪心</p>
<p><a href="https://www.acwing.com/solution/content/2615/%E6%9B%B4%E6%96%B0%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%EF%BC%88%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%89">https://www.acwing.com/solution/content/2615/更新维护区间（很重要）</a></p>
<h2 id="2-第二章-数据结构"><a href="#2-第二章-数据结构" class="headerlink" title="2.第二章 数据结构"></a>2.第二章 数据结构</h2><h3 id="链表和邻接表"><a href="#链表和邻接表" class="headerlink" title="链表和邻接表"></a>链表和邻接表</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>用的最多的是邻接表</p>
<p>（存储图和树）</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8.png"></p>
<p><a href="https://www.acwing.com/solution/content/16251/">https://www.acwing.com/solution/content/16251/</a></p>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>添加的顺序不能反</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8F%8C%E9%93%BE%E8%A1%A8.png"></p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><p>表达式求值(中缀 后缀）一般是二元（不包括符号）</p>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>例题 <a href="https://www.luogu.com.cn/problem/P2947">https://www.luogu.com.cn/problem/P2947</a></p>
<p>例题 <a href="https://leetcode.cn/problems/daily-temperatures/description/">https://leetcode.cn/problems/daily-temperatures/description/</a></p>
<p><a href="https://www.bilibili.com/video/BV1VN411J7S7/?spm_id_from=333.337.search-card.all.click&vd_source=4452cbcad134fb17ec9cfb03a0acbdac">https://www.bilibili.com/video/BV1VN411J7S7/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4452cbcad134fb17ec9cfb03a0acbdac</a> 灵神讲解很好</p>
<p>例题洛谷P2866</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ans= <span class="number">0</span>; </span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;=n ; i ++)&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;	</span><br><span class="line">		<span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;st.<span class="built_in">top</span>()&lt;=x)&#123;</span><br><span class="line">				st.<span class="built_in">pop</span>();</span><br><span class="line">				cnt--; </span><br><span class="line">			&#125;</span><br><span class="line">			ans+=cnt;</span><br><span class="line">			st.<span class="built_in">push</span>(x);</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>框架 入 、出、记录答案</p>
<p><a href="https://www.bilibili.com/video/BV1bM411X72E/?spm_id_from=333.337.search-card.all.click&vd_source=4452cbcad134fb17ec9cfb03a0acbdac">https://www.bilibili.com/video/BV1bM411X72E/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4452cbcad134fb17ec9cfb03a0acbdac</a> 灵神讲解很好</p>
<p><a href="https://www.acwing.com/solution/content/97229/%E8%BF%99%E4%B8%AA%E8%AE%B2%E8%A7%A3%E5%BE%88%E5%A5%BD">https://www.acwing.com/solution/content/97229/这个讲解很好</a></p>
<p>题目 <a href="https://www.acwing.com/blog/content/29432/">https://www.acwing.com/blog/content/29432/</a></p>
<p>C++用STL双端队列deque非常方便</p>
<p>例题 洛谷P2032</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> v,id;&#125;a[N];</span><br><span class="line">deque&lt;node&gt; q;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">		cin &gt;&gt; a[i].v;</span><br><span class="line">		a[i].id = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;q.<span class="built_in">back</span>().v&lt;a[i].v)&#123;</span><br><span class="line">			q.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		q.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">		<span class="keyword">if</span>(q.<span class="built_in">front</span>().id==i-k)q.<span class="built_in">pop_front</span>();</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k)cout &lt;&lt; q.<span class="built_in">front</span>().v&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好消息，虽然抽象但是题型固定就那几个</p>
<p><a href="https://www.acwing.com/solution/content/27437/">https://www.acwing.com/solution/content/27437/</a> 这个非常易于适合理解单调栈</p>
<p>单调栈：见博客</p>
<p>单调队列：见博客<a href="https://blog.csdn.net/qq_50285142/article/details/120245122?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169761847116800180675961%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169761847116800180675961&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120245122-null-null.142%5Ev96%5Epc_search_result_base1&utm_term=%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97&spm=1018.2226.3001.4187">https://blog.csdn.net/qq_50285142/article/details/120245122?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169761847116800180675961%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169761847116800180675961&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120245122-null-null.142^v96^pc_search_result_base1&amp;utm_term=%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97&amp;spm=1018.2226.3001.4187</a></p>
<h3 id="kmp算法（略）"><a href="#kmp算法（略）" class="headerlink" title="kmp算法（略）"></a>kmp算法（略）</h3><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><p>题一般字符串字母类型少</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"></p>
<p>算法竞赛里的trie树最多26个或者52个字母</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p><a href="https://leetcode.cn/circle/discuss/qmjuMW/">https://leetcode.cn/circle/discuss/qmjuMW/</a></p>
<p><a href="https://www.acwing.com/solution/content/33345/">https://www.acwing.com/solution/content/33345/</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2068345">https://cloud.tencent.com/developer/article/2068345</a> </p>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/994805354108403712?type=7&page=1">https://pintia.cn/problem-sets/994805342720868352/exam/problems/994805354108403712?type=7&amp;page=1</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> p[N];<span class="comment">//定义多个集合</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    经上述可以发现,每个集合中只有祖宗节点的p[x]值等于他自己,即:</span></span><br><span class="line"><span class="comment">    p[x]=x;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">    <span class="comment">//找到了便返回祖宗节点的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(*op==<span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);<span class="comment">//集合合并操作</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))</span><br><span class="line">        <span class="comment">//如果祖宗节点一样,就输出yes</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/zhxmdefj/p/11117791.html">https://www.cnblogs.com/zhxmdefj/p/11117791.html</a> 并查集、带权并查集博客</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><a href="https://www.acwing.com/solution/content/3258/">https://www.acwing.com/solution/content/3258/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line"><span class="keyword">while</span> (n -- )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    heap.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (heap.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> b = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">    res += a + b;</span><br><span class="line">    heap.<span class="built_in">push</span>(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>字符串哈希适用场景：不考虑冲突，不能映射成0</p>
<p>字符串前缀哈希值</p>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><h5 id="例题-动态求区间和"><a href="#例题-动态求区间和" class="headerlink" title="例题 动态求区间和"></a>例题 动态求区间和</h5><h6 id="树状数组-1"><a href="#树状数组-1" class="headerlink" title="树状数组"></a>树状数组</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100009</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],tr[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个数的间隔，背下来就行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第x个数加上v</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//因为树状数组的性质，加一个数，只影响logn个数，所有不用全加完</span></span><br><span class="line">    <span class="comment">//从当前位置开始加，每个间隔是lowbit(i)，一直加到最后</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        tr[i]+=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回x的前缀和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qurry</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//因为树状数组的性质，求前缀和，只用加logn个数，所有不用全加完</span></span><br><span class="line">    <span class="comment">//从当前位置开始累加，每个间隔是lowbit(i)，一直加到i==0停止</span></span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i!=<span class="number">0</span>;i-=<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        cnt+=tr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">add</span>(i,a[i]);<span class="comment">//第i个数加上a[i]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k,x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;k,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">qurry</span>(y)-<span class="built_in">qurry</span>(x<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">add</span>(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="这道题的线段树方法"><a href="#这道题的线段树方法" class="headerlink" title="这道题的线段树方法"></a>这道题的线段树方法</h6><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"></p>
<h6 id="4倍空间的原因"><a href="#4倍空间的原因" class="headerlink" title="4倍空间的原因"></a>4倍空间的原因</h6><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%AE%B5%E6%A0%914%E5%80%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8E%9F%E5%9B%A0.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N];<span class="comment">//记录一下权重</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;<span class="comment">//左右区间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum;<span class="comment">//总和</span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];<span class="comment">//记得开 4 倍空间 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//利用它的两个儿子来算一下它的当前节点信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;<span class="comment">//左儿子 u&lt;&lt;1 ,右儿子 u&lt;&lt;1|1  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">/*第一个参数，当前节点编号，第二个参数，左边界，第三个参数，右边界*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)tr[u]=&#123;l,r,w[r]&#125;;<span class="comment">//如果当前已经是叶节点了，那我们就直接赋值就可以了</span></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则的话，说明当前区间长度至少是 2 对吧，那么我们需要把当前区间分为左右两个区间，那先要找边界点</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u]=&#123;l,r&#125;;<span class="comment">//这里记得赋值一下左右边界的初值</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="comment">//边界的话直接去计算一下 l + r 的下取整</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);<span class="comment">//先递归一下左儿子</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);<span class="comment">//然后递归一下右儿子</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">push_up</span>(u);<span class="comment">//做完两个儿子之后的话呢 push_up 一遍u 啊，更新一下当前节点信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">//查询的过程是从根结点开始往下找对应的一个区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;tr[u].r&lt;=r)<span class="keyword">return</span> tr[u].sum;<span class="comment">//如果当前区间已经完全被包含了，那么我们直接返回它的值就可以了</span></span><br><span class="line">    <span class="comment">//否则的话我们需要去递归来算</span></span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;<span class="comment">//计算一下我们 当前 区间的中点是多少</span></span><br><span class="line">    <span class="comment">//先判断一下和左边有没有交集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;<span class="comment">//用 sum 来表示一下我们的总和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=l)sum+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);<span class="comment">//看一下我们当前区间的中点和左边有没有交集</span></span><br><span class="line">    <span class="keyword">if</span>(r&gt;=mid+<span class="number">1</span>)<span class="comment">//看一下我们当前区间的中点和右边有没有交集</span></span><br><span class="line">    sum+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> v)</span><span class="comment">//第一个参数也就是当前节点的编号,第二个参数是要修改的位置，第三个参数是要修改的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==tr[u].r)tr[u].sum+=v; <span class="comment">//如果当前已经是叶节点了，那我们就直接让他的总和加上 v 就可以了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//否则</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//看一下 x 是在左半边还是在右半边</span></span><br><span class="line">      <span class="keyword">if</span>(x&lt;=mid)<span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,x,v);<span class="comment">//如果是在左半边，那就找左儿子</span></span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,v);<span class="comment">//如果在右半边，那就找右儿子</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//更新完之后当前节点的信息就要发生变化对吧，那么我们就需要 pushup 一遍</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">push_up</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);<span class="comment">/*第一个参数是根节点的下标，根节点是一号点，然后初始区间是 1 到 n */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//后面的话就是一些修改操作了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k,a,b;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!k)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,a,b));<span class="comment">//求和的时候，也是传三个参数，第一个的话是根节点的编号 ，第二个的话是我们查询的区间 </span></span><br><span class="line">        <span class="comment">//第一个参数也就是当前节点的编号</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,a,b);<span class="comment">//第一个参数是根节点的下标,第二个参数是要修改的位置，第三个参数是要修改的值</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：Elegant</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/40394/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h5 id="区间求和例题-洛谷P3368"><a href="#区间求和例题-洛谷P3368" class="headerlink" title="区间求和例题:洛谷P3368"></a>区间求和例题:洛谷P3368</h5><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E4%BE%8B%E9%A2%98.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> b[N];</span><br><span class="line"><span class="type">int</span> tr[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt;= n; i += <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">		tr[i] += c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">		res += tr[i];</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		b[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">add</span>(i,b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m --)&#123;</span><br><span class="line">		<span class="type">int</span> op;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="type">int</span> x,y,k;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">			<span class="built_in">add</span>(x,k);</span><br><span class="line">			<span class="built_in">add</span>(y + <span class="number">1</span>,-k);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> x;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			cout &lt;&lt; <span class="built_in">query</span>(x) &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h3 id="线段树-1"><a href="#线段树-1" class="headerlink" title="线段树"></a>线段树</h3><p><a href="https://blog.csdn.net/weixin_45697774/article/details/104274713">https://blog.csdn.net/weixin_45697774/article/details/104274713</a></p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//递归建树</span></span><br><span class="line">    tree[i].l=l;tree[i].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;<span class="comment">//如果这个节点是叶子节点</span></span><br><span class="line">        tree[i].sum=input[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(i*<span class="number">2</span>,l,mid);<span class="comment">//分别构造左子树和右子树</span></span><br><span class="line">    <span class="built_in">build</span>(i*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    tree[i].sum=tree[i*<span class="number">2</span>].sum+tree[i*<span class="number">2</span>+<span class="number">1</span>].sum;<span class="comment">//刚才我们发现的性质return ;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="简单（无pushdown）的线段树"><a href="#简单（无pushdown）的线段树" class="headerlink" title="简单（无pushdown）的线段树"></a>简单（无pushdown）的线段树</h4><h4 id="1、单点修改，区间查询"><a href="#1、单点修改，区间查询" class="headerlink" title="1、单点修改，区间查询"></a>1、单点修改，区间查询</h4><h5 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].l&gt;=l &amp;&amp; tree[i].r&lt;=r)<span class="comment">//如果这个区间被完全包括在目标区间里面，直接返回这个区间的值</span></span><br><span class="line">        <span class="keyword">return</span> tree[i].sum;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].r&lt;l || tree[i].l&gt;r)  <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果这个区间和目标区间毫不相干，返回0</span></span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>].r&gt;=l)  s+=<span class="built_in">search</span>(i*<span class="number">2</span>,l,r);<span class="comment">//如果这个区间的左儿子和目标区间又交集，那么搜索左儿子</span></span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>+<span class="number">1</span>].l&lt;=r)  s+=<span class="built_in">search</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r);<span class="comment">//如果这个区间的右儿子和目标区间又交集，那么搜索右儿子</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> dis,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].l==tree[i].r)&#123;<span class="comment">//如果是叶子节点，那么说明找到了</span></span><br><span class="line">        tree[i].sum+=k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis&lt;=tree[i*<span class="number">2</span>].r)  <span class="built_in">add</span>(i*<span class="number">2</span>,dis,k);<span class="comment">//在哪往哪跑</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="built_in">add</span>(i*<span class="number">2</span>+<span class="number">1</span>,dis,k);</span><br><span class="line">    tree[i].sum=tree[i*<span class="number">2</span>].sum+tree[i*<span class="number">2</span>+<span class="number">1</span>].sum;<span class="comment">//返回更新</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、区间修改，单点查询"><a href="#2、区间修改，单点查询" class="headerlink" title="2、区间修改，单点查询"></a>2、区间修改，单点查询</h4><h5 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r) &#123;</span><br><span class="line">		tr[p].num += k;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = tr[p].l + tr[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid) <span class="built_in">modify</span>(p &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">	<span class="keyword">if</span>(r &gt; mid) <span class="built_in">modify</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单点查询"><a href="#单点查询" class="headerlink" title="单点查询"></a>单点查询</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ans += tr[p].num;<span class="comment">//一路加起来</span></span><br><span class="line">	<span class="keyword">if</span>(tr[p].l == tr[p].r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = tr[p].l + tr[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x &lt;= mid) <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-第三章-搜索与图论"><a href="#3-第三章-搜索与图论" class="headerlink" title="3.第三章 搜索与图论"></a>3.第三章 搜索与图论</h2><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/DFS%E5%92%8CBFS.png"></p>
<h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/DFS.png"></p>
<p>两个很重要的概念：回溯 剪枝</p>
<p>每个DFS都一定对应一个搜索树</p>
<p><a href="https://www.acwing.com/solution/content/30988/">https://www.acwing.com/solution/content/30988/</a></p>
<p><a href="https://www.luogu.com.cn/problem/solution/P5194">https://www.luogu.com.cn/problem/solution/P5194</a> 求最大值 从后往前</p>
<p><a href="https://www.cnblogs.com/lcez56jsy/p/10705834.html">https://www.cnblogs.com/lcez56jsy/p/10705834.html</a>  迷宫 求方案数</p>
<p><a href="https://www.luogu.com.cn/problem/P1101">https://www.luogu.com.cn/problem/P1101</a> 单词方阵（搜一个字符串）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;  <span class="comment">//方向数组 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>,<span class="number">-1</span>, <span class="number">1</span>,<span class="number">-1</span>, <span class="number">0</span> , <span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="type">const</span> string cmp = <span class="string">&quot;yizhong&quot;</span>; <span class="comment">// 比较数组 </span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> A[maxn][maxn], ans[maxn][maxn];</span><br><span class="line"><span class="type">int</span> mark[maxn][maxn], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++) &#123;  <span class="comment">//枚举8个方向 </span></span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">6</span>;j++) &#123; <span class="comment">//以1个方向比较 “izhong”   </span></span><br><span class="line">			<span class="type">int</span> nx = x + j*dx[i];    </span><br><span class="line">			<span class="type">int</span> ny = y + j*dy[i];</span><br><span class="line">			<span class="keyword">if</span>(nx &lt; <span class="number">1</span> || nx &gt; n || ny &lt; <span class="number">1</span> || ny &gt; n) &#123; <span class="comment">//判越界 </span></span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(cmp[j] != A[nx][ny]) &#123;  <span class="comment">//判断第j位是否符合 </span></span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">6</span>;j++) &#123; <span class="comment">//符合就记录在ans数组里 </span></span><br><span class="line">			<span class="type">int</span> nx = x + j*dx[i];</span><br><span class="line">			<span class="type">int</span> ny = y + j*dy[i];</span><br><span class="line">			ans[nx][ny] = A[nx][ny];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++) &#123;</span><br><span class="line">			cin &gt;&gt; A[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123; </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(A[i][j] == <span class="string">&#x27;y&#x27;</span>) <span class="built_in">dfs</span>(i,j);<span class="comment">//如果发现有y就开始搜索 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123; <span class="comment">//输出 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(ans[i][j] == <span class="number">0</span>) ans[i][j] = <span class="string">&#x27;*&#x27;</span>;<span class="comment">//如果没有改动就输出* </span></span><br><span class="line">			cout &lt;&lt; ans[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><a href="https://www.luogu.com.cn/problem/P1019">https://www.luogu.com.cn/problem/P1019</a> 单词接龙<a href="https://www.cnblogs.com/dx123/p/17486562.html">https://www.cnblogs.com/dx123/p/17486562.html</a></p>
<p>最后ans - 1是因为有前面的*，前面加 * 可以方便j从1开始枚举，不用特判</p>
<p>经典题目 八皇后</p>
<h3 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h3><p>迷宫问题 <a href="https://cloud.tencent.com/developer/article/1176807%E6%8A%8ADFS%E5%92%8CBFS%E5%8C%BA%E5%88%AB%E8%AE%B2%E7%9A%84%E5%BE%88%E6%98%8E%E7%99%BD">https://cloud.tencent.com/developer/article/1176807把DFS和BFS区别讲的很明白</a></p>
<p>2019蓝桥 <a href="https://blog.csdn.net/m0_56312312/article/details/123671856">https://blog.csdn.net/m0_56312312/article/details/123671856</a> 思路很好，字典序数组按照顺序排好了，第一个得到的路径必然是最短的并且字典序最小的</p>
<p><a href="https://www.luogu.com.cn/paste/sa0zary9">https://www.luogu.com.cn/paste/sa0zary9</a> 题单</p>
<p><strong>例题</strong>蓝桥国赛 迷宫与陷阱 ：<a href="https://www.luogu.com.cn/problem/P8673">https://www.luogu.com.cn/problem/P8673</a></p>
<p><strong>例题</strong> 全球变暖 <a href="https://www.acwing.com/problem/content/description/1235/">https://www.acwing.com/problem/content/description/1235/</a></p>
<p>注意 迷宫（这题不建议用bfs） <a href="https://www.cnblogs.com/lcez56jsy/p/10705834.html">https://www.cnblogs.com/lcez56jsy/p/10705834.html</a> 和DFS的区别（回溯）</p>
<p><strong>Flood fill(洪水灌溉)</strong></p>
<p>1.多少个连通块</p>
<p>不是所有最短路都用BFS，只能当边权都是1时，一般情况都是用最短路算法</p>
<p>BFS函数里一般都用队列</p>
<p>2.多少个被淹没</p>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"><span class="type">int</span> judge[N][N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i  ++)&#123;</span><br><span class="line">            <span class="type">int</span> x = dx[i] + t.first, y = dy[i] +t.second;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=n&amp;&amp;vis[x][y]==<span class="literal">false</span>&amp;&amp;g[x][y]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;(g[x<span class="number">-1</span>][y]==<span class="string">&#x27;.&#x27;</span>||g[x+<span class="number">1</span>][y]==<span class="string">&#x27;.&#x27;</span>||g[x][y<span class="number">-1</span>]==<span class="string">&#x27;.&#x27;</span>||g[x][y+<span class="number">1</span>]==<span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">                vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">                judge[x][y]= <span class="number">1</span>; </span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)&#123;</span><br><span class="line">            <span class="type">int</span> x=  dx[i] +t.first,y=dy[i]+t.second;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=n&amp;&amp;g[x][y]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;vis[x][y]==<span class="literal">false</span>)&#123;</span><br><span class="line">                vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(judge[x][y]==<span class="number">0</span>)&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x,y&#125;);               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;#&#x27;</span>&amp;&amp;vis[i][j]==<span class="literal">false</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i,j&#125;);</span><br><span class="line">                <span class="built_in">BFS1</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j  = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;#&#x27;</span>&amp;&amp;vis[i][j]==<span class="literal">false</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;i,j&#125;);</span><br><span class="line">                    <span class="built_in">BFS2</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>岛屿个数 <a href="https://www.acwing.com/problem/content/description/4962/">https://www.acwing.com/problem/content/description/4962/</a></p>
<p>两个BFS，特别好的题，注意海水渗透要8个方向。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> ,<span class="number">-1</span>, - <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i  &lt; <span class="number">8</span>; i ++)&#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x&lt;=n+<span class="number">1</span> &amp;&amp; y &gt;=<span class="number">0</span> &amp;&amp; y &lt;=m + <span class="number">1</span> &amp;&amp; g[x][y]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                g[x][y] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">    g[x][y] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)&#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y&gt;=<span class="number">1</span>&amp;&amp;y &lt;=m &amp;&amp; (g[x][y]==<span class="string">&#x27;0&#x27;</span>||g[x][y]==<span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">                g[x][y] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="comment">// int ans = 0;</span></span><br><span class="line">    <span class="keyword">while</span>(T --)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="string">&#x27;0&#x27;</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">             <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">                cin &gt;&gt; g[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">BFS1</span>();</span><br><span class="line">        <span class="comment">//能形成岛屿，里面肯定不会进海水</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="built_in">BFS2</span>(i, j);</span><br><span class="line">                    <span class="comment">// cout &lt;&lt;&quot;i = =&quot; &lt;&lt; i &lt;&lt;&quot;j == &quot; &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">                    ans ++;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="树与图的存储（10-21）"><a href="#树与图的存储（10-21）" class="headerlink" title="树与图的存储（10.21）"></a>树与图的存储（10.21）</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8.png"></p>
<p><a href="https://www.bilibili.com/video/BV1mJ411S7BB/?spm_id_from=333.337.search-card.all.click&vd_source=4452cbcad134fb17ec9cfb03a0acbdac">https://www.bilibili.com/video/BV1mJ411S7BB/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4452cbcad134fb17ec9cfb03a0acbdac</a></p>
<p>这个链式前向星讲的特别好↑</p>
<p>树是特殊的图，所以只讲图就行</p>
<p>图：有向图，无向图，边有无方向，无向图可以看作特殊的有向图，所以只要看有向图</p>
<p>有向图（a-&gt;b)：</p>
<p>邻接矩阵g[a] [b]  a-&gt;b,有重边保留一条就可以了</p>
<p>邻接表			</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E8%A1%A8.png">			</p>
<h3 id="树与图的深度优先遍历"><a href="#树与图的深度优先遍历" class="headerlink" title="树与图的深度优先遍历"></a>树与图的深度优先遍历</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86.png" alt="image-20231204141022311"></p>
<p> **<a href="https://leetcode.cn/circle/discuss/FyPTTM/**%E5%AE%9D%E8%97%8F">https://leetcode.cn/circle/discuss/FyPTTM/**宝藏</a></p>
<p>讲解了为什么要反向建边 <a href="https://www.163.com/dy/article/E01JK0430538071X.html">https://www.163.com/dy/article/E01JK0430538071X.html</a></p>
<p><strong><a href="https://www.luogu.com.cn/problem/P3916">https://www.luogu.com.cn/problem/P3916</a></strong></p>
<p>洛谷这个题↑正向遍历超时了 n 1e5 ，用反向遍历更适合</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8F%8D%E5%90%91%E5%BB%BA%E8%BE%B9.png"></p>
<p>思路真妙，把大的先走完，打上标记，肯定就是最大的了</p>
<p><strong>图的讲解</strong>(2023.12.4很好) <a href="https://www.luogu.com.cn/problem/solution/P5318">https://www.luogu.com.cn/problem/solution/P5318</a></p>
<p><strong>这个邻接表写法</strong>nice↓</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> visited[MAXN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> cur)</span> </span>&#123;<span class="comment">//x指当前所在的节点，cur指已遍历过的节点个数</span></span><br><span class="line">	visited[x] = <span class="literal">true</span>;<span class="comment">//标记以避免重复访问</span></span><br><span class="line">	cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//输出</span></span><br><span class="line">	<span class="keyword">if</span> (cur == n) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;G[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">		<span class="keyword">if</span> (!visited[G[x][i]]) <span class="built_in">dfs</span>(G[x][i], cur+<span class="number">1</span>);<span class="comment">//记得要判断是否遍历过</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="built_in">sizeof</span>(visited));<span class="comment">//记得一定要清空</span></span><br><span class="line">	visited[x] = <span class="literal">true</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(x);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();<span class="comment">//记得要弹出，否则会一直在第一层遍历</span></span><br><span class="line">		cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//输出</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;G[v].<span class="built_in">size</span>(); i++) </span><br><span class="line">			<span class="keyword">if</span> (!visited[G[v][i]]) &#123;</span><br><span class="line">				visited[G[v][i]] = <span class="literal">true</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(G[v][i]);<span class="comment">//记得要入队</span></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		G[u].<span class="built_in">push_back</span>(v);<span class="comment">//标准邻接表建有向图</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(), G[i].<span class="built_in">end</span>());<span class="comment">//标准vector排序</span></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//完结撒花！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>非常重要</strong>!!!由前+中&#x2F;后+中构建序列 模板（字符串切割 + 练习STL substr）</p>
<p><a href="https://www.luogu.com.cn/problem/solution/P1827">https://www.luogu.com.cn/problem/solution/P1827</a> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">由中序和前序求后序</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string pre,inor;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string pre,string inor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre.<span class="built_in">empty</span>())<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">char</span> root = pre[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> k = inor.<span class="built_in">find</span>(root);</span><br><span class="line">    pre.<span class="built_in">erase</span>(pre.<span class="built_in">begin</span>());</span><br><span class="line">    string leftpre = pre.<span class="built_in">substr</span>(<span class="number">0</span>,k);</span><br><span class="line">    string rightpre = pre.<span class="built_in">substr</span>(k);</span><br><span class="line">    string leftinor = inor.<span class="built_in">substr</span>(<span class="number">0</span>,k);</span><br><span class="line">    string rightinor = inor.<span class="built_in">substr</span>(k + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(leftpre,leftinor);</span><br><span class="line">    <span class="built_in">dfs</span>(rightpre,rightinor);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,root);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; inor &gt;&gt;pre ;</span><br><span class="line">    <span class="built_in">dfs</span>(pre,inor);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.luogu.com.cn/problem/P1030">https://www.luogu.com.cn/problem/P1030</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">由中序和后序求前序</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string inor,post;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(string inor,string post)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(post.<span class="built_in">empty</span>())<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">char</span> root = post[post.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    post.<span class="built_in">erase</span>(post.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> k = inor.<span class="built_in">find</span>(root);</span><br><span class="line">    </span><br><span class="line">    string inorleft = inor.<span class="built_in">substr</span>(<span class="number">0</span>,k);</span><br><span class="line">    string inorright= inor.<span class="built_in">substr</span>(k + <span class="number">1</span>);</span><br><span class="line">    string postleft = post.<span class="built_in">substr</span>(<span class="number">0</span>,k);</span><br><span class="line">    string postright = post.<span class="built_in">substr</span>(k);</span><br><span class="line">    cout &lt;&lt; root;</span><br><span class="line">    <span class="built_in">solve</span>(inorleft,postleft);</span><br><span class="line">    <span class="built_in">solve</span>(inorright,postright);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; inor &gt;&gt; post;</span><br><span class="line">    <span class="built_in">solve</span>(inor,post);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string pre,inor;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(string pre,string inor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre.<span class="built_in">empty</span>())<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果序列空了，就没必要继续了</span></span><br><span class="line">    <span class="type">char</span> root=pre[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//取到前序序列的首字母，即根节点</span></span><br><span class="line">    <span class="type">int</span> k=inor.<span class="built_in">find</span>(root);</span><br><span class="line">    <span class="comment">//找到中序序列中根节点的位置</span></span><br><span class="line">    pre.<span class="built_in">erase</span>(pre.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="comment">//删去前序序列中的根节点</span></span><br><span class="line">    string leftpre=pre.<span class="built_in">substr</span>(<span class="number">0</span>,k);</span><br><span class="line">    <span class="comment">//从0开始切割k个</span></span><br><span class="line">    string rightpre=pre.<span class="built_in">substr</span>(k);</span><br><span class="line">    <span class="comment">//从k开始切割到最后</span></span><br><span class="line">    string leftinor=inor.<span class="built_in">substr</span>(<span class="number">0</span>,k);</span><br><span class="line">    <span class="comment">//从0开始切割k个</span></span><br><span class="line">    string rightinor=inor.<span class="built_in">substr</span>(k+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//从k+1开始切割到最后</span></span><br><span class="line">    <span class="built_in">work</span>(leftpre,leftinor);</span><br><span class="line">    <span class="built_in">work</span>(rightpre,rightinor);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,root);</span><br><span class="line">    <span class="comment">//因为要输出后序序列，所以是左右根</span></span><br><span class="line">    <span class="comment">//先遍历左子树，再右子树，再根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;inor&gt;&gt;pre;</span><br><span class="line">    <span class="built_in">work</span>(pre,inor);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树与图的宽度优先遍历-待更"><a href="#树与图的宽度优先遍历-待更" class="headerlink" title="树与图的宽度优先遍历(待更)"></a>树与图的宽度优先遍历(待更)</h3><h3 id="DAG-与-拓扑排序（12-4）"><a href="#DAG-与-拓扑排序（12-4）" class="headerlink" title="DAG() 与 拓扑排序（12.4）"></a>DAG() 与 拓扑排序（12.4）</h3><p><strong>知乎的讲解</strong>，很好↓[知识点]</p>
<p><a href="https://zhuanlan.zhihu.com/p/135094687">https://zhuanlan.zhihu.com/p/135094687</a></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F1.png"></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F2.png"></p>
<p><strong>拓扑排序邻接表版</strong>[代码]</p>
<p><a href="https://www.acwing.com/problem/content/850/">https://www.acwing.com/problem/content/850/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];<span class="comment">//邻接表 </span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//队列操作 </span></span><br><span class="line"><span class="type">int</span> d[N];<span class="comment">//统计入度 </span></span><br><span class="line"><span class="type">int</span> n,m,cnt,ans[N];<span class="comment">//ans数组记录答案 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i &lt;= m; i ++)&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		cin &gt;&gt; x&gt;&gt; y;</span><br><span class="line">		G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		d[y]++;<span class="comment">//统计入度 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(d[i]==<span class="number">0</span>)q.<span class="built_in">push</span>(i);<span class="comment">//1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		ans[cnt++] = t;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; G[t].<span class="built_in">size</span>();i  ++)&#123;</span><br><span class="line">			d[G[t][i]]--;<span class="comment">//删边操作 </span></span><br><span class="line">			<span class="keyword">if</span>(d[G[t][i]]==<span class="number">0</span>) q.<span class="built_in">push</span>(G[t][i]);<span class="comment">//删完后入度为0的话，放入队列 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt == n)<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;cnt; i ++)cout &lt;&lt; ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt;<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例题</strong></p>
<p><strong>我发现下面两道需要拓扑的题，只需要把一些求ans的代码放到模板里，模板还是不变的</strong></p>
<p>1 .洛谷P1113 杂务</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	每个任务前的耗时最长的任务相加即为答案，详情看洛谷深入浅出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ind[N], f[N], a[N];  <span class="comment">// ind--入度   f--答案   a--时间</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edge[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            cin &gt;&gt; y;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            edge[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">            ind[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步骤一</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ind[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            f[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> rhs = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 步骤二</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edge[rhs].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> u = edge[rhs][i];</span><br><span class="line">            ind[u]--;</span><br><span class="line">            <span class="keyword">if</span> (ind[u] == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(u);  <span class="comment">// 步骤三</span></span><br><span class="line">            f[u] = <span class="built_in">max</span>(f[u], f[rhs] + a[u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[i]);   <span class="comment">// 统计答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.P4017 最大食物链计数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	先找出所有入度为0的，初始链数为1，后面搜到的每个点，都等于各个点链数之和，详情看洛谷深入浅出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> ans[N],outd[N],ind[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;G[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        ind[y]++;</span><br><span class="line">        outd[x]++;</span><br><span class="line">        G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ind[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);  </span><br><span class="line">			ans[i] = <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; G[t].<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">        <span class="type">int</span> x = G[t][i];</span><br><span class="line">        ind[x] --;</span><br><span class="line">		<span class="keyword">if</span>(ind[x]==<span class="number">0</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[x] = (ans[x] + ans[t])%<span class="number">80112002</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(outd[i]==<span class="number">0</span>)&#123;</span><br><span class="line">        res= (res + ans[i])%<span class="number">80112002</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="力扣总结精华"><a href="#力扣总结精华" class="headerlink" title="力扣总结精华"></a>力扣总结精华</h4><p><a href="https://leetcode.cn/circle/discuss/FyPTTM/#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">https://leetcode.cn/circle/discuss/FyPTTM/#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84</a> </p>
<p>有权单源最短路</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9C%89%E6%9D%83%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.png"></p>
<p>无权单源最短路</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%97%A0%E6%9D%83%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF.png"></p>
<p>带权全源最短路</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%B8%A6%E6%9D%83%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.png"></p>
<p>如果是无权单源，可以BFS+队列，有权就不行了</p>
<h5 id="带权单源最短路"><a href="#带权单源最短路" class="headerlink" title="带权单源最短路"></a>带权单源最短路</h5><h6 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h6><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89.png"></p>
<p><strong>视频演示</strong>：</p>
<p> <a href="https://www.bilibili.com/video/BV1zz4y1m7Nq/?spm_id_from=333.788.recommend_more_video.0&vd_source=4452cbcad134fb17ec9cfb03a0acbdac">https://www.bilibili.com/video/BV1zz4y1m7Nq/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=4452cbcad134fb17ec9cfb03a0acbdac</a></p>
<p>各个算法用途比较</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%90%84%E7%A7%8D%E6%AF%94%E8%BE%83.png"></p>
<p><a href="https://www.acwing.com/solution/content/5806/">https://www.acwing.com/solution/content/5806/</a>  代码详解</p>
<h6 id="朴素版"><a href="#朴素版" class="headerlink" title="朴素版"></a>朴素版</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N];    <span class="comment">//为稠密阵所以用邻接矩阵存储</span></span><br><span class="line"><span class="type">int</span> dist[N];    <span class="comment">//用于记录每一个点距离第一个点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">//用于记录该点的最短距离是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);     <span class="comment">//初始化距离  0x3f代表无限大</span></span><br><span class="line"></span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;  <span class="comment">//第一个点到自身的距离为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)      <span class="comment">//有n个点所以要进行n次 迭代</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">-1</span>;       <span class="comment">//t存储当前访问的点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)   <span class="comment">//这里的j代表的是从1号点开始</span></span><br><span class="line">        <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[j]&lt;dist[t]))     </span><br><span class="line">            t=j;</span><br><span class="line"></span><br><span class="line">    st[t]=<span class="literal">true</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)           <span class="comment">//依次更新每个点所到相邻的点路径值</span></span><br><span class="line">        dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//如果第n个点路径为无穷大即不存在最低路径</span></span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);    <span class="comment">//初始化图 因为是求最短路径</span></span><br><span class="line">                            <span class="comment">//所以每个点初始为无限大</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">    g[x][y]=<span class="built_in">min</span>(g[x][y],z);     <span class="comment">//如果发生重边的情况则保留最短的一条边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">Dijkstra</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于「稠密图」，应当使用「朴素版」，对于「稀疏图」，应当使用「优先队列版」</strong></p>
<h6 id="堆优化版"><a href="#堆优化版" class="headerlink" title="堆优化版"></a>堆优化版</h6><p><strong>（vector邻接表，但是大多用的还是数组模拟邻接表）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	邻接表存的话不用考虑重边，dij算法会取最小的</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 稀疏图用邻接表来存</span></span><br><span class="line">vector&lt;vector&lt;PII&gt;&gt;G;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，</span></span><br><span class="line">    <span class="comment">// 其次在从堆中拿出来的时候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。</span></span><br><span class="line">    <span class="comment">// 这个顺序不能倒，pair排序时是先根据first，再根据second，</span></span><br><span class="line">     <span class="comment">// 这里显然要根据距离排序,对pair排序默认先对first,所以first放距离更省事 </span></span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap;</span><br><span class="line">	heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span>(heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">		heap.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> distance = t.first,node = t.second;</span><br><span class="line">		<span class="keyword">if</span>(st[node])<span class="keyword">continue</span>;</span><br><span class="line">		st[node] = <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[node].<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">			<span class="type">int</span> newNode = G[node][i].first;</span><br><span class="line">			<span class="type">int</span> len = G[node][i].second;</span><br><span class="line">			<span class="keyword">if</span>(dist[newNode]&gt;dist[node] + len)&#123;</span><br><span class="line">				dist[newNode] = dist[node] + len;</span><br><span class="line">				heap.<span class="built_in">push</span>(&#123;dist[newNode],newNode&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	G.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">		<span class="type">int</span> x,y,z;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">		G[x].<span class="built_in">push_back</span>(&#123;y,z&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">dijkstra</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="最短路径-和-各种第二标量"><a href="#最短路径-和-各种第二标量" class="headerlink" title="最短路径 和 各种第二标量"></a>最短路径 和 各种第二标量</h6><p>例题PTA甲级 <strong>紧急事件</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> G[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="type">int</span> dist[<span class="number">510</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">510</span>];<span class="comment">//救援队</span></span><br><span class="line"><span class="type">int</span> n,m,c1,c2;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">510</span>];</span><br><span class="line"><span class="type">int</span> weight[<span class="number">510</span>];</span><br><span class="line"><span class="type">int</span> num2[<span class="number">510</span>];<span class="comment">//最短路数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[c1] = <span class="number">0</span>;</span><br><span class="line">    num2[c1] = <span class="number">1</span>;</span><br><span class="line">    num[c1] = weight[c1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;(t==<span class="number">-1</span>||dist[t] &gt;dist[j]))&#123;</span><br><span class="line">                t = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">            <span class="comment">// dist[j] = min(dist[j],dist[t] + G[t][j]);</span></span><br><span class="line">            <span class="keyword">if</span>(dist[t] + G[t][j] &lt; dist[j])&#123;</span><br><span class="line">                dist[j] = dist[t] + G[t][j];</span><br><span class="line">                num[j] = num[t] + weight[j];</span><br><span class="line">                num2[j] = num2[t];</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dist[t] +G[t][j] == dist[j])&#123;</span><br><span class="line">            num2[j] += num2[t];</span><br><span class="line">            <span class="keyword">if</span>(weight[j] + num[t] &gt; num[j])</span><br><span class="line">            num[j] = num[t] + weight[j];</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; num2[c2] &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;num[c2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt;n &gt;&gt; m &gt;&gt;c1&gt;&gt;c2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; weight[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(G,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> G);</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        G[x][y] = <span class="built_in">min</span>(G[x][y],z);</span><br><span class="line">        G[y][x] = <span class="built_in">min</span>(G[y][x],z);</span><br><span class="line">        <span class="comment">// G[x][y] = G[y][x]= z;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>书P375</p>
<h6 id="打印路径"><a href="#打印路径" class="headerlink" title="打印路径"></a>打印路径</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> v)</span></span>&#123; <span class="comment">//s是起点编号，v是当前访问的顶点编号(从终点开始递归)</span></span><br><span class="line">	<span class="keyword">if</span>(v == s)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(s,pre[v]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么无法处理负边</p>
<p><a href="https://www.acwing.com/solution/content/6320/%E8%AF%A6%E8%A7%A3%E5%BE%88%E5%A5%BD">https://www.acwing.com/solution/content/6320/详解很好</a></p>
<h6 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman-ford"></a>bellman-ford</h6><p><strong>与spfa比可能唯一的好处：如果是有边数限制的话，就不能用spfa了</strong></p>
<p>时间复杂度 N*M</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%B4%9F%E6%9D%83%E5%9B%9E%E8%B7%AF.png"></p>
<p>如果有负权回路的话，最短路不一定存在了</p>
<p><strong>bellman-ford是可以求出是否有负环的,但平时不用，时间复杂度太高，后面SPFA会用到</strong></p>
<p><strong>鸽巢（抽屉）原理</strong></p>
<h6 id="Spfa"><a href="#Spfa" class="headerlink" title="Spfa"></a>Spfa</h6><h5 id="多源汇最短路"><a href="#多源汇最短路" class="headerlink" title="多源汇最短路"></a>多源汇最短路</h5><h6 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h6><h2 id="4-第四章-数学知识（12-10）"><a href="#4-第四章-数学知识（12-10）" class="headerlink" title="4.第四章 数学知识（12.10）"></a>4.第四章 数学知识（12.10）</h2><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p><strong>（要很熟练）</strong></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2.png"></p>
<p>转换成10进制用的秦九韶算法，迭代方式提升效率</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>洛谷 P1469 找筷子</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%89%BE%E7%AD%B7%E5%AD%90%E9%A2%98%E8%A7%A3.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//交换律 结合律 把偶数的先结合成0，最后只剩落单的和0异或还是它自己</span></span><br><span class="line"><span class="type">int</span> ans,n,a;<span class="comment">//ans是所有数异或之后的结果，也就是题目所求的落单的筷子的数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">   	  	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">		ans^=a;<span class="comment">//把所有的数都异或起来</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加法原理与乘法原理"><a href="#加法原理与乘法原理" class="headerlink" title="加法原理与乘法原理"></a>加法原理与乘法原理</h3><p>结果可能很大，要对指定数字取余数。不能全部乘完之后再取余数，因为中间结果可能会溢出。可以乘完一次就取一次余数。实际上，加法或者乘法都可以这样做：</p>
<p>(a+b+c)%k &#x3D; ((a+b)%k + c)%k</p>
<p>(a * b * c) % k &#x3D; ((a<em>b)%k * c</em>)%k</p>
<h3 id="组合数问题"><a href="#组合数问题" class="headerlink" title="组合数问题"></a>组合数问题</h3><p>例题</p>
<p><strong>洛谷 P2822 [NOIP2016 提高组] 组合数问题</strong></p>
<p>| 同余定理，前面是除数，后面是被除数</p>
<p>杨辉三角的性质</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c[<span class="number">2010</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> t,k,m,n;</span><br><span class="line">	cin &gt;&gt; t &gt;&gt; k;</span><br><span class="line">	<span class="comment">//先设置一个杨辉三角</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2000</span>; i ++)&#123;</span><br><span class="line">		c[i][<span class="number">0</span>] = c[i][i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j= <span class="number">1</span>; j &lt; i ; j ++)</span><br><span class="line">            <span class="comment">//加法计算可以在途中取余</span></span><br><span class="line">			c[i][j] = (c[i<span class="number">-1</span>][j] + c[i<span class="number">-1</span>][j<span class="number">-1</span>])%k;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">		<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(i,m); j ++)</span><br><span class="line">					ans+=c[i][j] == <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">			cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BA%A6%E6%95%B0.png"></p>
<p>例题 P2926 [USACO08DEC] Patting Heads S</p>
<p>未解决</p>
<h4 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h4><h4 id="约数个数和约数之和-两个公式"><a href="#约数个数和约数之和-两个公式" class="headerlink" title="约数个数和约数之和(两个公式)"></a>约数个数和约数之和(两个公式)</h4><h4 id="约数个数证明："><a href="#约数个数证明：" class="headerlink" title="约数个数证明："></a>约数个数证明：</h4><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E8%AF%81%E6%98%8E.png"></p>
<h3 id="质数和合数"><a href="#质数和合数" class="headerlink" title="质数和合数"></a>质数和合数</h3><p><a href="https://blog.csdn.net/TpeterH/article/details/115891290">所以，在以后的算法学习中，大家可以有意识地去使用线性筛进行解题，防止白给。除了这两种筛素数的方法，其实还有更加优秀的，时间复杂度低于O(N)的筛法，这里本人能力有限，就不进行介绍了，有兴趣的同学可以自己去查找相关资料。</a></p>
<h4 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            primes[cnt++]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i) st[j]=<span class="literal">true</span>;<span class="comment">//可以用质数就把所有的合数都筛掉；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//primes数组用来存放质数</span></span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="comment">//st[i], i为质数则为false否则为true</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes[cnt++] = i;</span><br><span class="line">        <span class="comment">//假设primes[0]为n最小的质因子,i为最大的因数，</span></span><br><span class="line">        <span class="comment">//易知若primes[i]中i&gt;0,则会进入循环后产生多余的标记。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//标记;primes[j]一定是primes[j]*i的最小质因子</span></span><br><span class="line">            st[primes[j]*i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//表明primes[j]一定是i的最小质因子,没有必要再遍历,primes要小于等于i的最小质因子</span></span><br><span class="line">            <span class="comment">//这样能保证每个数遍历一遍,而没有重复</span></span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h4><p><a href="https://www.acwing.com/solution/content/9813/">https://www.acwing.com/solution/content/9813/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;cin&gt;&gt;a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=a/i;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(a%i==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    a/=i;</span><br><span class="line">                    s++;</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s&lt;&lt;endl;  </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;<span class="number">1</span>) cout&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="number">1</span>&lt;&lt;endl; <span class="comment">///</span></span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p><a href="https://blog.csdn.net/m0_52072919/article/details/116400820?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%BF%AB%E9%80%9F%E5%B9%82&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-116400820.nonecase&spm=1018.2226.3001.4187">https://blog.csdn.net/m0_52072919/article/details/116400820?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%BF%AB%E9%80%9F%E5%B9%82&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-116400820.nonecase&amp;spm=1018.2226.3001.4187</a></p>
<p>这个博客很好</p>
<p>模板</p>
<p><a href="https://www.acwing.com/problem/content/description/877/">https://www.acwing.com/problem/content/description/877/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> base, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> power, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> result = <span class="number">1</span>;   </span><br><span class="line">	<span class="keyword">while</span> (power &gt; <span class="number">0</span>)           </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (power &amp; <span class="number">1</span>)         							</span><br><span class="line">			result = result * base % p;   </span><br><span class="line">			<span class="comment">//根据公式每个项都取余数后在再做累乘</span></span><br><span class="line">		base = base * base % p ;   </span><br><span class="line">			<span class="comment">//根据公式每个项都取余数后在再做平方操作      						</span></span><br><span class="line">		power &gt;&gt;= <span class="number">1</span>;         						</span><br><span class="line">	&#125;</span><br><span class="line">			<span class="comment">//根据公式在最后的的结果上再来一次取余数</span></span><br><span class="line">	<span class="keyword">return</span> result % p;       </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        <span class="type">int</span> base,power,p;</span><br><span class="line">        cin &gt;&gt; base &gt;&gt; power &gt;&gt; p;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">qmi</span>(base,power,p)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%BF%AB%E9%80%9F%E5%B9%82.png"></p>
<p><strong>n mod 2可以写成n &amp; 1, n&#x2F;2 可以写成 n &gt;&gt; 1</strong></p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%BA%94%E7%94%A8.png"></p>
<h4 id="欧拉（Euler）函数"><a href="#欧拉（Euler）函数" class="headerlink" title="欧拉（Euler）函数"></a>欧拉（<strong>Euler</strong>）函数</h4><p><a href="https://www.acwing.com/solution/content/62556/">https://www.acwing.com/solution/content/62556/</a></p>
<p>证明可用容斥原理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll k;cin&gt;&gt;k;</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        ll res=x;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=x/i;i++)</span><br><span class="line">            <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(x%i==<span class="number">0</span>)x/=i;</span><br><span class="line">                res=res/i*(i<span class="number">-1</span>);   <span class="comment">//注意先除再乘  N/pk*(pk-1); </span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">1</span>)res=res/x*(x<span class="number">-1</span>);</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="5-第五章-动态规划"><a href="#5-第五章-动态规划" class="headerlink" title="5.第五章 动态规划"></a>5.第五章 动态规划</h2><h3 id="闫式DP分析法"><a href="#闫式DP分析法" class="headerlink" title="闫式DP分析法"></a>闫式DP分析法</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/y%E5%BC%8Fdp.png"></p>
<p>从集合角度分析DP问题，求<strong>有限集合</strong>的最值&#x2F;个数..</p>
<p>状态表示：每次划分一个子集 （化零为整） —多做题，刚开始的时候很难想到如何表示，做过类似的题才能大概率写出来</p>
<p>属性：存的是什么东西,max&#x2F;min&#x2F;count之类的</p>
<p>状态计算:化整为零</p>
<p>f[i]的子集，不重复，不遗漏(f[i]的全部都被包含),比如取最大值，给每个子集的最大值取个max。</p>
<p>集合划分的套路：寻找最后一个不同点</p>
<p>想学好dp整理好模型很重要，比如选择问题-背包模型，子序列问题-最长上升子序列这种模型</p>
<p>dp很看重经验，(做过类似的题)</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/y%E5%BC%8Fdp02.png"></p>
<p><img src="/../img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/y%E5%BC%8Fdp04.png" alt="image-20240116203838110"></p>
<p>状态表示 f[i,j]</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/y%E5%BC%8Fdp03.png"></p>
<p>选择物品i的方案不一定存在，要判断j 是否&gt;&#x3D;v[i]</p>
<p>例题 <a href="https://www.acwing.com/problem/content/1214/">https://www.acwing.com/problem/content/1214/</a> 地宫取宝</p>
<p>重复调用的问题适合改动态规划</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BB%BB%E4%BD%95dp%E9%83%BD%E8%83%BD%E4%BB%8E%E9%80%92%E5%BD%92%E5%85%A5%E6%89%8B.png"></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BB%8E%E9%80%92%E5%BD%92%E5%85%A5%E6%89%8B%E4%B8%80%E7%BB%B4dp.png"></p>
<h3 id="斐波那契数列优化"><a href="#斐波那契数列优化" class="headerlink" title="斐波那契数列优化"></a>斐波那契数列优化</h3><p>1.递归</p>
<p>2.记忆化</p>
<p>3.dp</p>
<p>4.使用两个变量</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/dp%E6%B5%81%E7%A8%8B.png"></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/dp%E5%85%A5%E9%97%A8.png"></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/dp%E5%85%A5%E9%97%A8%E6%80%9D%E8%B7%AF.png"></p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%86%99%E5%87%BA%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95.png"></p>
<p><strong>动态规划就是递推的子集</strong></p>
<p><strong>例题</strong></p>
<p><img src="/../../../../../CS/%E7%AC%94%E8%AE%B0/acwing%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/dp%E4%BE%8B%E9%A2%98.png" alt="image-20231221194259987"></p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h4><p>一维 01 逆序，完全 正序</p>
<h4 id="记化化搜索"><a href="#记化化搜索" class="headerlink" title="记化化搜索"></a>记化化搜索</h4><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%83%8C%E5%8C%85%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2.png"></p>
<h4 id="二维DP"><a href="#二维DP" class="headerlink" title="二维DP"></a>二维DP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> v[MAXN];    <span class="comment">// 体积</span></span><br><span class="line"><span class="type">int</span> w[MAXN];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN];  <span class="comment">// f[i][j], j体积下前i个物品的最大价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// 能装，需进行决策是否选择第i个物品</span></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;           </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="滚动数组（优化成一维DP）版本"><a href="#滚动数组（优化成一维DP）版本" class="headerlink" title="滚动数组（优化成一维DP）版本"></a>滚动数组（优化成一维DP）版本</h4><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/01%E4%B8%80%E7%BB%B4.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    <span class="comment">//这里如果从0~m的话，可能会用到上层被这层覆盖的值</span></span><br><span class="line">   <span class="comment">//可以自己画表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];  <span class="comment">// 优化前</span></span><br><span class="line">            f[j] = f[j];            <span class="comment">// 优化后，该行自动成立，可省略。</span></span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);  <span class="comment">// 优化前</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);                   <span class="comment">// 优化后</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><h5 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h5><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E4%BA%8C%E7%BB%B4.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> N,V;</span><br><span class="line"><span class="type">int</span> v[P],w[P];</span><br><span class="line"><span class="type">int</span> mm[P][P];</span><br><span class="line"><span class="comment">// int dfs(int x,int spV)&#123;</span></span><br><span class="line"><span class="comment">//     if(x &gt; N || spV &lt; 0)mm[x][spV] = 0;</span></span><br><span class="line"><span class="comment">//     else if(spV &lt; v[x]) mm[x][spV]=dfs(x+1,spV);</span></span><br><span class="line"><span class="comment">//   return mm[x][spV];</span></span><br><span class="line"><span class="comment">//             else mm[x][spV] = max(dfs(x + 1,spV),dfs(x,spV-v[x])+w[x]);</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int res = dfs(1,V);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= V; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i])mm[i][j] = mm[i - <span class="number">1</span>][j];</span><br><span class="line">    <span class="keyword">else</span> mm[i][j] = <span class="built_in">max</span>(mm[i - <span class="number">1</span>][j],mm[i][j - v[i]]+ w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; mm[N][V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维正序枚举，下面的写法不舒服，可以把上面的改成正序的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j&lt;=m ;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span> ; k*v[i]&lt;=j ; k++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h5><p>可以画图，体积从正序枚举是对的，每个物品可以无限取，从倒序枚举是错的，不然和01（只能取一次）一样了，画个图就ok</p>
<p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E4%B8%80%E7%BB%B4.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)</span><br><span class="line">    <span class="comment">//j小于v[i]的不改变</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = v[i] ; j&lt;=m ;j++)</span><br><span class="line">&#123;</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">&#125;</span><br><span class="line">	cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h4><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.png"></p>
<p> 多重背包问题 I (数据范围100，n^3没超1e7-1e8)</p>
<p><a href="https://www.acwing.com/problem/content/4/">https://www.acwing.com/problem/content/4/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;<span class="comment">//枚举背包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;<span class="comment">//枚举体积</span></span><br><span class="line">        <span class="comment">//k从0开始，可能一个都不选</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i]; k ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;=  k * v[i])&#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多重背包问题 II (正常做会超)</p>
<p><a href="https://www.acwing.com/problem/content/5/">https://www.acwing.com/problem/content/5/</a></p>
<p>分组背包</p>
<h5 id="二维-1"><a href="#二维-1" class="headerlink" title="二维"></a>二维</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];  <span class="comment">//只从前i组物品中选，当前体积小于等于j的最大值</span></span><br><span class="line"><span class="type">int</span> v[N][N],w[N][N],s[N];   <span class="comment">//v为体积，w为价值，s代表第i组物品的个数</span></span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s[i];j++)&#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];  <span class="comment">//读入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        f[i][j]=f[i<span class="number">-1</span>][j];  <span class="comment">//不选</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;s[i];k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i][k])     f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="一维-1"><a href="#一维-1" class="headerlink" title="一维"></a>一维</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">因为只用到了第i<span class="number">-1</span>列，所以可以仿照<span class="number">01</span>背包的套路逆向枚举体积</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N][N],w[N][N],s[N];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s[i];j++)&#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;s[i];k++)&#123;    <span class="comment">//for(int k=s[i];k&gt;=1;k--)也可以</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i][k])     f[j]=<span class="built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h4><p><strong>例题 洛谷 1130红牌</strong></p>
<p>例题  <a href="https://www.acwing.com/problem/content/description/8/">https://www.acwing.com/problem/content/description/8/</a></p>
<h4 id="背包问题的变种"><a href="#背包问题的变种" class="headerlink" title="背包问题的变种"></a>背包问题的变种</h4><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%98%E7%A7%8D.png"></p>
<h5 id="01背包求方案数"><a href="#01背包求方案数" class="headerlink" title="01背包求方案数"></a>01背包求方案数</h5><p><strong>例题 acwing278. 数字组合</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="comment">/*int dfs(int u,int spSum)&#123;</span></span><br><span class="line"><span class="comment">	if(f[u][spSum]!=0)return f[u][spSum];</span></span><br><span class="line"><span class="comment">	else if(spSum != 0 &amp;&amp; u &gt; n)f[u][spSum] = 0;</span></span><br><span class="line"><span class="comment">	else if(spSum &lt; 0)f[u][spSum] = 0;</span></span><br><span class="line"><span class="comment">	else if(spSum == 0)f[u][spSum] = 1;</span></span><br><span class="line"><span class="comment">	else f[u][spSum] = dfs(u +1,spSum) + dfs(u + 1,spSum - a[u]);</span></span><br><span class="line"><span class="comment">	return f[u][spSum];</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n &gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 当和为0时，方案数为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            f[i][j] = f[i + <span class="number">1</span>][j];  <span class="comment">// 不选择第i个数</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= a[i]) &#123;</span><br><span class="line">                f[i][j] += f[i + <span class="number">1</span>][j - a[i]];  <span class="comment">// 选择第i个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][m];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="01背包求具体方案"><a href="#01背包求具体方案" class="headerlink" title="01背包求具体方案"></a>01背包求具体方案</h5><p>为什么逆序枚举？</p>
<p><a href="https://www.acwing.com/problem/content/description/12/">https://www.acwing.com/problem/content/description/12/</a></p>
<p><a href="https://blog.csdn.net/yl_puyu/article/details/109960323%E8%A7%A3%E9%87%8A%E5%BE%88%E5%A5%BD">https://blog.csdn.net/yl_puyu/article/details/109960323解释很好</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            f[i][j] = f[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i + <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在此，f[1][m]就是最大数量</span></span><br><span class="line">    <span class="type">int</span> j = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        <span class="keyword">if</span> (j &gt;= v[i] &amp;&amp; f[i][j] == f[i + <span class="number">1</span>][j - v[i]] + w[i]) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            j -= v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="01背包求最优方案数"><a href="#01背包求最优方案数" class="headerlink" title="01背包求最优方案数"></a>01背包求最优方案数</h5><p>背包例题</p>
<p><a href="https://www.luogu.com.cn/paste/s2v5pn69">https://www.luogu.com.cn/paste/s2v5pn69</a></p>
<p>洛谷P1802 5倍经验日（01背包变<strong>形问题）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">这是一道变了形的<span class="number">01</span>背包</span><br><span class="line"></span><br><span class="line">首先我们因为和每个人打都一定有经验所以一定都要打一遍。</span><br><span class="line"></span><br><span class="line">所以不难想到max=lose[<span class="number">1</span>]+lose[<span class="number">2</span>]......+lose[n]+某些磕了药打赢的多出的经验值</span><br><span class="line"></span><br><span class="line">因此我们可以进行一个转换，把价值记为win[i]-lose[i]，溶剂就是要打赢磕的药，然后要使价值总和最大，然后就变成了基础的零一背包了。。。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> win[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> lose[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;lose[i],&amp;win[i],&amp;v[i]);</span><br><span class="line">        a[i]=win[i]-lose[i];</span><br><span class="line">        sum=sum+lose[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=m;j&gt;=v[i];j--)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="number">5</span>*(f[m]+sum));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="完全背包求方案数"><a href="#完全背包求方案数" class="headerlink" title="完全背包求方案数"></a>完全背包求方案数</h5><p>例题</p>
<p><a href="https://www.acwing.com/problem/content/description/1373/">https://www.acwing.com/problem/content/description/1373/</a></p>
<p>题解：<a href="https://www.acwing.com/solution/content/31275/">https://www.acwing.com/solution/content/31275/</a></p>
<p>&#x2F;&#x2F;和01背包求方案数写法除了改循环条件几乎没区别</p>
<p><a href="https://www.acwing.com/problem/content/description/3385/">https://www.acwing.com/problem/content/description/3385/</a></p>
<h5 id="背包例题"><a href="#背包例题" class="headerlink" title="背包例题"></a>背包例题</h5><p><a href="https://www.luogu.com.cn/paste/s2v5pn69">https://www.luogu.com.cn/paste/s2v5pn69</a></p>
<h6 id="洛谷P1802-5倍经验日（01背包变形问题）"><a href="#洛谷P1802-5倍经验日（01背包变形问题）" class="headerlink" title="洛谷P1802 5倍经验日（01背包变形问题）"></a>洛谷P1802 5倍经验日（01背包变形问题）</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">这是一道变了形的<span class="number">01</span>背包</span><br><span class="line"></span><br><span class="line">首先我们因为和每个人打都一定有经验所以一定都要打一遍。</span><br><span class="line"></span><br><span class="line">所以不难想到max=lose[<span class="number">1</span>]+lose[<span class="number">2</span>]......+lose[n]+某些磕了药打赢的多出的经验值</span><br><span class="line"></span><br><span class="line">因此我们可以进行一个转换，把价值记为win[i]-lose[i]，溶剂就是要打赢磕的药，然后要使价值总和最大，然后就变成了基础的零一背包了。。。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> win[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> lose[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;lose[i],&amp;win[i],&amp;v[i]);</span><br><span class="line">        a[i]=win[i]-lose[i];</span><br><span class="line">        sum=sum+lose[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=m;j&gt;=v[i];j--)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="number">5</span>*(f[m]+sum));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h4><p>例题 石子合并 <a href="https://www.acwing.com/problem/content/description/284/">https://www.acwing.com/problem/content/description/284/</a></p>
<p>视频讲解的很好</p>
<p>绝大部分区间dp问题，先枚举区间长度，再枚举区间左端点</p>
<h4 id="状态机DP"><a href="#状态机DP" class="headerlink" title="状态机DP"></a>状态机DP</h4><p><a href="https://blog.csdn.net/qq_42958831/article/details/130059756">https://blog.csdn.net/qq_42958831/article/details/130059756</a></p>
<p>这个博客把灵神的思路讲得很明白</p>
<p><a href="https://www.acwing.com/problem/content/description/1059/">https://www.acwing.com/problem/content/description/1059/</a></p>
<p>题解讲得很好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> f[N][M][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//初始状态f[0][0][0]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j][<span class="number">0</span>] = f[i - <span class="number">1</span>][j][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (j) f[i][j][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] + w[i]);</span><br><span class="line">            f[i][j][<span class="number">1</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j][<span class="number">1</span>], f[i - <span class="number">1</span>][j][<span class="number">0</span>] - w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; ++ j) res = <span class="built_in">max</span>(res, f[n][j][<span class="number">0</span>]); <span class="comment">//目标状态f[n][j][0]</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://www.acwing.com/problem/content/1058/">https://www.acwing.com/problem/content/1058/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> A =<span class="number">1e5</span>,B = <span class="number">10</span>,C = <span class="number">2</span>, inf = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> dp[A][B][C];</span><br><span class="line"><span class="type">int</span> w[A];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; w[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[0][2][0] = 0;</span></span><br><span class="line">    <span class="comment">// dp[0][2][1] = -inf;</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++ i) dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j ++)&#123;</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + w[i]);</span><br><span class="line">            dp[i][j][<span class="number">1</span>] = dp[i - <span class="number">1</span>][j][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(j)dp[i][j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - w[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i ++)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(dp[n][i][<span class="number">0</span>],ans);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h4><p><a href="https://www.bilibili.com/video/BV17o4y187h1/?spm_id_from=333.337.search-card.all.click&vd_source=4452cbcad134fb17ec9cfb03a0acbdac">https://www.bilibili.com/video/BV17o4y187h1/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4452cbcad134fb17ec9cfb03a0acbdac</a>  树的直径讲解</p>
<p>例题见视频下方链接</p>
<p><a href="https://www.cnblogs.com/RioTian/p/15163878.html">https://www.cnblogs.com/RioTian/p/15163878.html</a> 博客</p>
<h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%A1%E7%89%B9%E5%85%B0%E9%80%9A%E9%A1%B9.png"></p>
<p><a href="https://leetcode.cn/circle/discuss/lWYCzv/">https://leetcode.cn/circle/discuss/lWYCzv/</a></p>
<p><strong>例题1 进出栈序列</strong></p>
<h4 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a><strong>线性DP</strong></h4><h5 id="最长上升子序列I"><a href="#最长上升子序列I" class="headerlink" title="最长上升子序列I"></a>最长上升子序列I</h5><p>算法1<br>(动态规划) O(n2)</p>
<p>状态表示：f[i]表示从第一个数字开始算，以w[i]结尾的最大的上升序列。(以w[i]结尾的所有上升序列中属性为最大值的那一个)</p>
<p>状态计算（集合划分）：j∈(0,1,2,..,i-1), 在w[i] &gt; w[j]时，<br>f[i] &#x3D; max(f[i], f[j] + 1)。<br>有一个边界，若前面没有比i小的，f[i]为1（自己为结尾）。</p>
<p>最后在找f[i]的最大值。</p>
<p>时间复杂度<br>O(n2)<br>状态数(n) * 转移数(n)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mx = <span class="number">1</span>;    <span class="comment">// 找出所计算的f[i]之中的最大值，边算边找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;    <span class="comment">// 设f[i]默认为1，找不到前面数字小于自己的时候就为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; w[j]) f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);    <span class="comment">// 前一个小于自己的数结尾的最大上升子序列加上自己，即+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>算法2<br>(动态规划 + 二分) O(nlogn)</p>
<p>我认为可以延伸到<strong>求满足某个性质的一个子序列</strong></p>
<h5 id="最长上升子序列II-（数据范围n"><a href="#最长上升子序列II-（数据范围n" class="headerlink" title="最长上升子序列II （数据范围n&lt;1e5）"></a>最长上升子序列II （数据范围n&lt;1e5）</h5><p>这题解法特别好 </p>
<p><a href="https://www.acwing.com/solution/content/2192/">https://www.acwing.com/solution/content/2192/</a> 题解讲得很清楚<br>例题：蓝桥杯 <strong>接龙序列</strong></p>
<h5 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h5><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/y%E5%BC%8Fdp05.png"></p>
<p>状态计算可能有重复，只要不越界不遗漏就ok</p>
<h5 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><strong>编辑距离</strong></h5><p><img src="/img/%E8%87%AA%E7%94%A8%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/y%E5%BC%8Fdp06.png"></p>
<p>有f[i-1]基本i都要从1开始遍历</p>
<p><a href="https://www.acwing.com/activity/content/problem/content/1094/">https://www.acwing.com/activity/content/problem/content/1094/</a></p>
<h4 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h4><p>例题 <a href="https://www.luogu.com.cn/problem/P8687">https://www.luogu.com.cn/problem/P8687</a></p>
<h4 id="图上动态规划"><a href="#图上动态规划" class="headerlink" title="图上动态规划"></a>图上动态规划</h4><h3 id="日期问题"><a href="#日期问题" class="headerlink" title="日期问题"></a>日期问题</h3><p><a href="https://blog.51cto.com/u_15656645/5373606">https://blog.51cto.com/u_15656645/5373606</a> 蓝桥 <strong>日期问题模板</strong></p>
<p>闰年要被4整除并且不能被100整除或者能被400整除</p>
<p>(year % 4 &#x3D;&#x3D; 0 &amp;&amp; year % 100 !&#x3D; 0 )||(year % 400 &#x3D;&#x3D; 0)</p>
<p><a href="https://www.acwing.com/activity/content/problem/content/9436/">https://www.acwing.com/activity/content/problem/content/9436/</a></p>
<p><a href="https://www.acwing.com/blog/content/24163/%E9%A2%98%E8%A7%A3%E5%A4%A7%E5%90%88%E9%9B%86">https://www.acwing.com/blog/content/24163/题解大合集</a></p>
<p><a href="https://www.acwing.com/solution/content/37448/">https://www.acwing.com/solution/content/37448/</a> 这个代码的流程很好，可以当模板</p>
<h3 id="贡献法"><a href="#贡献法" class="headerlink" title="贡献法"></a>贡献法</h3><p><a href="https://blog.csdn.net/weixin_46239370/article/details/115262482">https://blog.csdn.net/weixin_46239370/article/details/115262482</a> 蓝桥杯 子串分值和 用到乘法原理和贡献法，题解很好</p>
]]></content>
      <categories>
        <category>自用</category>
      </categories>
      <tags>
        <tag>算法(刷题向)</tag>
      </tags>
  </entry>
</search>
